api_doc.mustache:
# {{{invokerPackage}}}{{{classname}}}_api{{#description}}
{{{.}}}{{/description}}

All URIs are relative to *{{{basePath}}}*

Method | HTTP request | Description
------------- | ------------- | -------------
{{#operations}}{{#operation}}**{{{operationIdOriginal}}}**]({{classname}}_api.md#{{{operationIdOriginal}}}) | **{{{httpMethod}}}** {{{path}}} | {{{summary}}}
{{/operation}}{{/operations}}

{{#operations}}
{{#operation}}
# **{{{operationIdOriginal}}}**
> {{#returnType}}{{{.}}} {{/returnType}}{{{operationIdOriginal}}}({{#authMethods}}ctx, {{/authMethods}}{{#allParams}}{{#required}}{{{paramName}}}{{^-last}}, {{/-last}}{{/required}}{{/allParams}}{{#hasOptionalParams}}optional{{/hasOptionalParams}})
{{{summary}}}{{#notes}}

{{{.}}}{{/notes}}

### Required Parameters
{{^allParams}}This endpoint does not need any parameter.{{/allParams}}{{#allParams}}{{#-last}}
Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------{{#authMethods}}
 **ctx** | **context.Context** | context containing the authentication | nil if no authentication{{/authMethods}}{{/-last}}{{/allParams}}{{#allParams}}{{#required}}
  **{{{paramName}}}** | {{#isPrimitiveType}}**{{{dataType}}}**{{/isPrimitiveType}}{{^isPrimitiveType}}[**{{{baseType}}}**]({{{baseType}}}.md){{/isPrimitiveType}}| {{{description}}} | {{#defaultValue}}[default to {{{.}}}]{{/defaultValue}}{{/required}}{{/allParams}}{{#hasOptionalParams}}
 **optional** | **map[string]interface{}** | optional parameters | nil if no parameters

### Optional Parameters
Optional parameters are passed through a map[string]interface{}.
{{#allParams}}{{#-last}}
Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------{{/-last}}{{/allParams}}{{#allParams}}
 **{{{paramName}}}** | {{#isPrimitiveType}}**{{{dataType}}}**{{/isPrimitiveType}}{{^isPrimitiveType}}[**{{{baseType}}}**]({{{baseType}}}.md){{/isPrimitiveType}}| {{{description}}} | {{#defaultValue}}[default to {{{.}}}]{{/defaultValue}}{{/allParams}}{{/hasOptionalParams}}

### Return type

{{#returnType}}{{#returnTypeIsPrimitive}}**{{{returnType}}}**{{/returnTypeIsPrimitive}}{{^returnTypeIsPrimitive}}[**{{{returnType}}}**]({{{returnBaseType}}}.md){{/returnTypeIsPrimitive}}{{/returnType}}{{^returnType}} (empty response body){{/returnType}}

### Authorization

{{^authMethods}}No authorization required{{/authMethods}}{{#authMethods}}[{{{name}}}](../README.md#{{{name}}}){{^-last}}, {{/-last}}{{/authMethods}}

### HTTP request headers

 - **Content-Type**: {{#consumes}}{{{mediaType}}}{{^-last}}, {{/-last}}{{/consumes}}{{^consumes}}Not defined{{/consumes}}
 - **Accept**: {{#produces}}{{{mediaType}}}{{^-last}}, {{/-last}}{{/produces}}{{^produces}}Not defined{{/produces}}

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

{{/operation}}
{{/operations}}
auth_.mustache_:
use std::collections::BTreeSet;
use crate::server::Authorization;
use serde::{Deserialize, Serialize};
// use swagger::{ApiError, auth::{Basic, Bearer}};

#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    pub sub: String,
    pub iss: String,
    pub aud: String,
    pub company: String,
    pub exp: u64,
    pub scopes: String,
}


pub trait AuthenticationApi {

    /// Method should be implemented (see example-code) to map Bearer-token to an Authorization
    fn bearer_authorization(&self, token: &Bearer) -> Result<Authorization, ApiError>;

    /// Method should be implemented (see example-code) to map ApiKey to an Authorization
    fn apikey_authorization(&self, token: &str) -> Result<Authorization, ApiError>;

    /// Method should be implemented (see example-code) to map Basic (Username:password) to an Authorization
    fn basic_authorization(&self, basic: &Basic) -> Result<Authorization, ApiError>;
} 

// Implement it for AllowAllAuthenticator (dummy is needed, but should not used as we have Bearer authorization)
// use swagger::auth::{AllowAllAuthenticator, RcBound, Scopes};

fn dummy_authorization() -> Authorization {
    // Is called when MakeAllowAllAuthenticator is added to the stack. This is not needed as we have Bearer-authorization in the example-code.
    // However, if you want to use it anyway this can not be unimplemented, so dummy implementation added.
    // unimplemented!()
    Authorization{
        subject: "Dummmy".to_owned(),
        scopes: Scopes::Some(BTreeSet::new()), // create an empty scope, as this should not be used
        issuer: None
    }
}

impl<T, RC> AuthenticationApi for AllowAllAuthenticator<T, RC>
where
    RC: RcBound,
    RC::Result: Send + 'static {

    /// Get method to map Bearer-token to an Authorization
    fn bearer_authorization(&self, _token: &Bearer) -> Result<Authorization, ApiError> {
        Ok(dummy_authorization())
    }

    /// Get method to map api-key to an Authorization
    fn apikey_authorization(&self, _apikey: &str) -> Result<Authorization, ApiError> {
        Ok(dummy_authorization())
    }

    /// Get method to map basic token to an Authorization
    fn basic_authorization(&self, _basic: &Basic) -> Result<Authorization, ApiError> {
        Ok(dummy_authorization())
    }
}
bin-cli.mustache:
//! CLI tool driving the API client
use anyhow::{anyhow, Context, Result};
{{#apiHasDeleteMethods}}
use dialoguer::Confirm;
{{/apiHasDeleteMethods}}
use log::{debug, info};
// models may be unused if all inputs are primitive types
#[allow(unused_imports)]
use {{{externCrateName}}}::{
    models, ApiNoContext, Client, ContextWrapperExt,
{{#apiInfo}}
  {{#apis}}
    {{#operations}}
      {{#operation}}
    {{{operationId}}}Response,
      {{/operation}}
    {{/operations}}
  {{/apis}}
{{/apiInfo}}
};
use simple_logger::SimpleLogger;
use structopt::StructOpt;
use swagger::{AuthData, ContextBuilder, EmptyContext, Push, XSpanIdString};

type ClientContext = swagger::make_context_ty!(
    ContextBuilder,
    EmptyContext,
    Option<AuthData>,
    XSpanIdString
);

{{! See code in RustServerCodegen if you are adding additional short option usage here. }}
#[derive(StructOpt, Debug)]
#[structopt(
    name = "{{appName}}",
    version = "{{version}}",
    about = "CLI access to {{appName}}"
)]
struct Cli {
    #[structopt(subcommand)]
    operation: Operation,

    /// Address or hostname of the server hosting this API, including optional port
    #[structopt(short = "a", long, default_value = "http://localhost")]
    server_address: String,

    /// Path to the client private key if using client-side TLS authentication
    #[cfg(not(any(target_os = "macos", target_os = "windows", target_os = "ios")))]
    #[structopt(long, requires_all(&["client-certificate", "server-certificate"]))]
    client_key: Option<String>,

    /// Path to the client's public certificate associated with the private key
    #[cfg(not(any(target_os = "macos", target_os = "windows", target_os = "ios")))]
    #[structopt(long, requires_all(&["client-key", "server-certificate"]))]
    client_certificate: Option<String>,

    /// Path to CA certificate used to authenticate the server
    #[cfg(not(any(target_os = "macos", target_os = "windows", target_os = "ios")))]
    #[structopt(long)]
    server_certificate: Option<String>,

    /// If set, write output to file instead of stdout
    #[structopt(short, long)]
    output_file: Option<String>,

    #[structopt(flatten)]
    verbosity: clap_verbosity_flag::Verbosity,
{{#apiHasDeleteMethods}}

    /// Don't ask for any confirmation prompts
    #[allow(dead_code)]
    #[structopt(short, long)]
    force: bool,
{{/apiHasDeleteMethods}}
{{#hasHttpBearerMethods}}

    /// Bearer token if used for authentication
    #[structopt(env = "{{#lambda.uppercase}}{{externCrateName}}{{/lambda.uppercase}}_BEARER_TOKEN", hide_env_values = true)]
    bearer_token: Option<String>,
{{/hasHttpBearerMethods}}
{{^hasHttpBearerMethods}}
{{#hasOAuthMethods}}

    /// Bearer token if used for authentication
    #[structopt(env = "{{#lambda.uppercase}}{{externCrateName}}{{/lambda.uppercase}}_BEARER_TOKEN", hide_env_values = true)]
    bearer_token: Option<String>,
{{/hasOAuthMethods}}
{{/hasHttpBearerMethods}}
}

#[derive(StructOpt, Debug)]
enum Operation {
{{#apiInfo}}
  {{#apis}}
    {{#operations}}
      {{#operation}}
        {{#summary}}
    /// {{{summary}}}
        {{/summary}}
    {{operationId}} {
      {{#allParams}}
        {{#description}}
        /// {{{description}}}
        {{/description}}
        {{^isPrimitiveType}}
        #[structopt(parse(try_from_str = parse_json){{#isArray}}, long{{/isArray}})]
        {{/isPrimitiveType}}
        {{#isByteArray}}
        #[structopt(parse(try_from_str = parse_json))]
        {{/isByteArray}}
        {{#isBinary}}
        #[structopt(parse(try_from_str = parse_json))]
        {{/isBinary}}
        {{#isBoolean}}
          {{#isPrimitiveType}}
            {{#vendorExtensions.x-provide-cli-short-opt}}
        #[structopt(short, long)]
            {{/vendorExtensions.x-provide-cli-short-opt}}
            {{^vendorExtensions.x-provide-cli-short-opt}}
        #[structopt(long)]
            {{/vendorExtensions.x-provide-cli-short-opt}}
          {{/isPrimitiveType}}
        {{/isBoolean}}
        {{{paramName}}}: {{^required}}Option<{{/required}}{{{dataType}}}{{^required}}>{{/required}},
      {{/allParams}}
    },
      {{/operation}}
    {{/operations}}
  {{/apis}}
{{/apiInfo}}
}

#[cfg(not(any(target_os = "macos", target_os = "windows", target_os = "ios")))]
fn create_client(args: &Cli, context: ClientContext) -> Result<Box<dyn ApiNoContext<ClientContext>>> {
    if args.client_certificate.is_some() {
        debug!("Using mutual TLS");
        let client = Client::try_new_https_mutual(
            &args.server_address,
            args.server_certificate.clone().unwrap(),
            args.client_key.clone().unwrap(),
            args.client_certificate.clone().unwrap(),
        )
        .context("Failed to create HTTPS client")?;
        Ok(Box::new(client.with_context(context)))
    } else if args.server_certificate.is_some() {
        debug!("Using TLS with pinned server certificate");
        let client =
            Client::try_new_https_pinned(&args.server_address, args.server_certificate.clone().unwrap())
                .context("Failed to create HTTPS client")?;
        Ok(Box::new(client.with_context(context)))
    } else {
        debug!("Using client without certificates");
        let client =
            Client::try_new(&args.server_address).context("Failed to create HTTP(S) client")?;
        Ok(Box::new(client.with_context(context)))
    }
}

#[cfg(any(target_os = "macos", target_os = "windows", target_os = "ios"))]
fn create_client(args: &Cli, context: ClientContext) -> Result<Box<dyn ApiNoContext<ClientContext>>> {
    let client =
        Client::try_new(&args.server_address).context("Failed to create HTTP(S) client")?;
    Ok(Box::new(client.with_context(context)))
}

#[tokio::main]
async fn main() -> Result<()> {
    let args = Cli::from_args();
    if let Some(log_level) = args.verbosity.log_level() {
        SimpleLogger::new().with_level(log_level.to_level_filter()).init()?;
    }

    debug!("Arguments: {:?}", &args);

{{#hasHttpBearerMethods}}
    let mut auth_data: Option<AuthData> = None;

    if let Some(ref bearer_token) = args.bearer_token {
        debug!("Using bearer token");
        auth_data = Some(AuthData::bearer(bearer_token));
    }
{{/hasHttpBearerMethods}}
{{^hasHttpBearerMethods}}
  {{#hasOAuthMethods}}
    let mut auth_data: Option<AuthData> = None;

    if let Some(ref bearer_token) = args.bearer_token {
        debug!("Using bearer token");
        auth_data = Some(AuthData::bearer(bearer_token));
    }
  {{/hasOAuthMethods}}
{{/hasHttpBearerMethods}}
{{^hasHttpBearerMethods}}
  {{^hasOAuthMethods}}
    let auth_data: Option<AuthData> = None;
  {{/hasOAuthMethods}}
{{/hasHttpBearerMethods}}

    #[allow(trivial_casts)]
    let context = swagger::make_context!(
        ContextBuilder,
        EmptyContext,
        auth_data,
        XSpanIdString::default()
    );

    let client = create_client(&args, context)?;

    let result = match args.operation {
      {{#apiInfo}}
        {{#apis}}
          {{#operations}}
            {{#operation}}
        Operation::{{operationId}} {
          {{#allParams}}
            {{paramName}},
          {{/allParams}}
        } => {
          {{#vendorExtensions.x-is-delete}}
            prompt(args.force, "This will delete the given entry, are you sure?")?;
          {{/vendorExtensions.x-is-delete}}
            info!("Performing a {{operationId}} request{{^pathParams}}");{{/pathParams}}{{#pathParams}}{{#-first}} on {:?}", ({{/-first}}{{/pathParams}}
              {{#pathParams}}
                &{{paramName}}{{^-last}},{{/-last}}
                {{#-last}}
            ));
                {{/-last}}
              {{/pathParams}}

            let result = client.{{{vendorExtensions.x-operation-id}}}(
              {{#allParams}}
                {{{paramName}}}{{#isArray}}.as_ref(){{/isArray}},
              {{/allParams}}
            ).await?;
            debug!("Result: {:?}", result);

            match result {
              {{#responses}}
                {{{operationId}}}Response::{{{vendorExtensions.x-response-id}}}
                {{#dataType}}
                  {{^hasHeaders}}
                (body)
                  {{/hasHeaders}}
                  {{#hasHeaders}}
                {
                    body,
                  {{/hasHeaders}}
                {{/dataType}}
                {{^dataType}}
                  {{#hasHeaders}}
                {
                  {{/hasHeaders}}
                {{/dataType}}
                {{#headers}}
                    {{{name}}},
                  {{#-last}}
                }
                  {{/-last}}
                {{/headers}}
                => "{{{vendorExtensions.x-response-id}}}\n".to_string()
                  {{#dataType}}
                   +
                  {{/dataType}}
                  {{^dataType}}
                    {{#hasHeaders}}
                    +
                    {{/hasHeaders}}
                    {{^hasHeaders}}
                    ,
                    {{/hasHeaders}}
                  {{/dataType}}
                {{#dataType}}
                  {{^hasHeaders}}
                    &serde_json::to_string_pretty(&body)?,
                  {{/hasHeaders}}
                  {{#hasHeaders}}
                    &format!("body: {}\n", serde_json::to_string_pretty(&body)?) +
                  {{/hasHeaders}}
                {{/dataType}}
                {{#headers}}
                    &format!(
                        "{{{name}}}: {}\n",
                        serde_json::to_string_pretty(&{{{name}}})?
                    ){{^-last}} +{{/-last}}{{#-last}},{{/-last}}
                {{/headers}}
              {{/responses}}
            }
        }
            {{/operation}}
          {{/operations}}
        {{/apis}}
      {{/apiInfo}}
    };

    if let Some(output_file) = args.output_file {
        std::fs::write(output_file, result)?
    } else {
        println!("{}", result);
    }
    Ok(())
}
{{#apiHasDeleteMethods}}

fn prompt(force: bool, text: &str) -> Result<()> {
    if force || Confirm::new().with_prompt(text).interact()? {
        Ok(())
    } else {
        Err(anyhow!("Aborting"))
    }
}
{{/apiHasDeleteMethods}}

// May be unused if all inputs are primitive types
#[allow(dead_code)]
fn parse_json<'a, T: serde::de::Deserialize<'a>>(json_string: &'a str) -> Result<T> {
    serde_json::from_str(json_string).map_err(|err| anyhow!("Error parsing input: {}", err))
}
cargo-config:
[build]
rustflags = [
    "-W", "missing_docs",  # detects missing documentation for public members

    "-W", "trivial_casts",  # detects trivial casts which could be removed

    "-W", "trivial_numeric_casts",  # detects trivial casts of numeric types which could be removed

    "-W", "unsafe_code",  # usage of `unsafe` code

    "-W", "unused_qualifications",  # detects unnecessarily qualified names

    "-W", "unused_extern_crates",  # extern crates that are never used

    "-W", "unused_import_braces",  # unnecessary braces around an imported item

    "-D", "warnings", # all warnings should be denied
]
Cargo.mustache:
[package]
name = "{{{packageName}}}"
version = "{{{packageVersion}}}"
{{#infoEmail}}
authors = ["{{{.}}}"]
{{/infoEmail}}
{{^infoEmail}}
authors = ["OpenAPI Generator team and contributors"]
{{/infoEmail}}
{{#appDescription}}
description = "{{{.}}}"
{{/appDescription}}
{{#licenseInfo}}
license = "{{.}}"
{{/licenseInfo}}
{{^licenseInfo}}
# Override this license by providing a License Object in the OpenAPI.
license = "Unlicense"
{{/licenseInfo}}
edition = "2018"
{{#publishRustRegistry}}
publish = ["{{.}}"]
{{/publishRustRegistry}}
{{#repositoryUrl}}
repository = "{{.}}"
{{/repositoryUrl}}
{{#documentationUrl}}
documentation = "{{.}}"
{{/documentationUrl}}
{{#homePageUrl}}
homepage = "{{.}}"
{{/homePageUrl}}

[features]
default = ["client", "server"]
client = [
{{#apiUsesMultipart}}
    "mime_0_2",
{{/apiUsesMultipart}}
{{#apiUsesMultipartFormData}}
    "multipart", "multipart/client", "swagger/multipart_form",
{{/apiUsesMultipartFormData}}
{{#apiUsesMultipartRelated}}
    "hyper_0_10", "mime_multipart", "swagger/multipart_related",
{{/apiUsesMultipartRelated}}
{{#usesUrlEncodedForm}}
    "serde_urlencoded",
{{/usesUrlEncodedForm}}
{{#hasCallbacks}}
    "serde_ignored", "regex", "percent-encoding", "lazy_static",
{{/hasCallbacks}}
{{! Anything added to the list below, should probably be added to the callbacks list below }}
    "hyper", "hyper-openssl", "hyper-tls", "native-tls", "openssl", "url"
]
server = [
{{#apiUsesMultipart}}
    "mime_0_2",
{{/apiUsesMultipart}}
{{#apiUsesMultipartFormData}}
    "multipart", "multipart/server", "swagger/multipart_form",
{{/apiUsesMultipartFormData}}
{{#apiUsesMultipartRelated}}
    "hyper_0_10", "mime_multipart", "swagger/multipart_related",
{{/apiUsesMultipartRelated}}
{{#hasCallbacks}}
    "native-tls", "hyper-openssl", "hyper-tls", "openssl",
{{/hasCallbacks}}
{{! Anything added to the list below, should probably be added to the callbacks list above }}
   "serde_ignored", "hyper", "regex", "percent-encoding", "url", "lazy_static"
]
cli = [
{{#apiHasDeleteMethods}}
  "dialoguer",
{{/apiHasDeleteMethods}}
  "anyhow", "clap-verbosity-flag", "simple_logger", "structopt", "tokio"
]
conversion = ["frunk", "frunk_derives", "frunk_core", "frunk-enum-core", "frunk-enum-derive"]

[target.'cfg(any(target_os = "macos", target_os = "windows", target_os = "ios"))'.dependencies]
native-tls = { version = "0.2", optional = true }
hyper-tls = { version = "0.5", optional = true }

[target.'cfg(not(any(target_os = "macos", target_os = "windows", target_os = "ios")))'.dependencies]
hyper-openssl = { version = "0.9", optional = true }
openssl = {version = "0.10", optional = true }

[dependencies]
# Common
async-trait = "0.1.24"
chrono = { version = "0.4", features = ["serde"] }
futures = "0.3"
swagger = { version = "6.1", features = ["serdejson", "server", "client", "tls", "tcp"] }
log = "0.4.0"
mime = "0.3"

serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
validator = { version = "0.16", features = ["derive"] }

# Crates included if required by the API definition
{{#usesXml}}
# TODO: this should be updated to point at the official crate once
# https://github.com/RReverser/serde-xml-rs/pull/45 is accepted upstream
serde-xml-rs = {git = "https://github.com/Metaswitch/serde-xml-rs" , branch = "master"}
{{/usesXml}}
{{#apiUsesMultipart}}
mime_0_2 = { package = "mime", version = "0.2.6", optional = true }
{{/apiUsesMultipart}}
{{#apiUsesMultipartFormData}}
multipart = { version = "0.16", default-features = false, optional = true }
{{/apiUsesMultipartFormData}}
{{#apiUsesUuid}}
uuid = {version = "1.3.1", features = ["serde", "v4"]}
{{/apiUsesUuid}}

# Common between server and client features
hyper = {version = "0.14", features = ["full"], optional = true}
{{#apiUsesMultipartRelated}}
mime_multipart = {version = "0.5", optional = true}
hyper_0_10 = {package = "hyper", version = "0.10", default-features = false, optional=true}
{{/apiUsesMultipartRelated}}
serde_ignored = {version = "0.1.1", optional = true}
url = {version = "2.1", optional = true}

# Client-specific
{{#usesUrlEncodedForm}}
serde_urlencoded = {version = "0.6.1", optional = true}
{{/usesUrlEncodedForm}}

# Server, and client callback-specific
lazy_static = { version = "1.4", optional = true }
percent-encoding = {version = "2.1.0", optional = true}
regex = {version = "1.3", optional = true}

# CLI-specific
anyhow = { version = "1", optional = true }
clap-verbosity-flag = { version = "0.3", optional = true }
simple_logger = { version = "2.0", features = ["stderr"], optional = true }
structopt = { version = "0.3", optional = true }
tokio = { version = "0.2", features = ["rt-threaded", "macros", "stream"], optional = true }
{{#apiHasDeleteMethods}}
dialoguer = { version = "0.8", optional = true }
{{/apiHasDeleteMethods}}

# Conversion
frunk = { version = "0.4.0", optional = true }
frunk_derives = { version = "0.4.0", optional = true }
frunk_core = { version = "0.4.0", optional = true }
frunk-enum-derive = { version = "0.3.0", optional = true }
frunk-enum-core = { version = "0.3.0", optional = true }

# Bearer authentication
jsonwebtoken = { version = "9.3.0", optional = false }

[dev-dependencies]
clap = "2.25"
env_logger = "0.7"
tokio = { version = "1.14", features = ["full"] }
native-tls = "0.2"

[target.'cfg(not(any(target_os = "macos", target_os = "windows", target_os = "ios")))'.dev-dependencies]
tokio-openssl = "0.6"
openssl = "0.10"

[[example]]
name = "client"
required-features = ["client"]

[[example]]
name = "server"
required-features = ["server"]

[[bin]]
name = "{{{packageName}}}"
path = "bin/cli.rs"
required-features = ["client", "cli"]
client-callbacks.mustache:
{{>server-imports}}
use crate::CallbackApi as Api;
{{#apiInfo}}
  {{#apis}}
    {{#operations}}
      {{#operation}}
        {{#callbacks}}
          {{#urls}}
            {{#requests}}
use crate::{{{operationId}}}Response;
            {{/requests}}
          {{/urls}}
        {{/callbacks}}
      {{/operation}}
    {{/operations}}
  {{/apis}}
{{/apiInfo}}

{{#callbacks}}
{{>server-paths}}
{{/callbacks}}

{{>server-make-service}}

{{>server-service-header}}
{{#apiInfo}}
  {{#apis}}
    {{#operations}}
      {{#operation}}
        {{#callbacks}}
          {{#urls}}
            {{#requests}}
{{>server-operation}}
            {{/requests}}
          {{/urls}}
        {{/callbacks}}
      {{/operation}}
    {{/operations}}
  {{/apis}}
{{/apiInfo}}
{{#callbacks}}
  {{#pathSet}}
            _ if path.matched(paths::ID_{{PATH_ID}}) => method_not_allowed(),
  {{/pathSet}}
{{/callbacks}}
{{>server-service-footer}}
/// Request parser for `Api`.
pub struct ApiRequestParser;
impl<T> RequestParser<T> for ApiRequestParser {
    fn parse_operation_id(request: &Request<T>) -> Option<&'static str> {
        let path = paths::GLOBAL_REGEX_SET.matches(request.uri().path());
        match *request.method() {
{{#apiInfo}}
  {{#apis}}
    {{#operations}}
      {{#operation}}
        {{#callbacks}}
          {{#urls}}
            {{#requests}}
            // {{{operationId}}} - {{{httpMethod}}} {{{path}}}
            hyper::Method::{{{vendorExtensions.x-http-method}}} if path.matched(paths::ID_{{{vendorExtensions.x-path-id}}}) => Some("{{{operationId}}}"),
            {{/requests}}
          {{/urls}}
        {{/callbacks}}
      {{/operation}}
    {{/operations}}
  {{/apis}}
{{/apiInfo}}
            _ => None,
        }
    }
}
client-imports.mustache:
use async_trait::async_trait;
use bytes::Bytes;
use futures::{Stream, Future, TryFutureExt, StreamExt};
use http_body_util::{BodyExt, Full};
use hyper::body::Incoming;
use hyper::header::{HeaderName, HeaderValue, CONTENT_TYPE};
use hyper::{Request, Response, StatusCode, Uri};
use percent_encoding::{utf8_percent_encode, AsciiSet};
use serde::{Deserialize, Serialize};
use std::borrow::Cow;
use std::convert::Infallible;
use std::error::Error as StdError;
use std::fmt;
use std::marker::PhantomData;
use std::path::Path;
use std::sync::{Arc, Mutex};
use std::task::{Context, Poll};
// use swagger::{ApiError, AuthData, Has, XSpanIdString};

{{#apiUsesMultipartFormData}}
use mime::Mime;
use multipart::server::Multipart;
{{/apiUsesMultipartFormData}}
{{#apiUsesMultipartRelated}}
use hyper::header::HeaderMap;
use mime_multipart::Node;
{{/apiUsesMultipartRelated}}

use crate::models;
use crate::header;

/// Константы для процентного кодирования
const FRAGMENT_ENCODE_SET: &AsciiSet = &percent_encoding::CONTROLS
    .add(b' ').add(b'"').add(b'<').add(b'>').add(b'`');
const ID_ENCODE_SET: &AsciiSet = &FRAGMENT_ENCODE_SET.add(b'|');client-mod.mustache:
{{>client-imports}}
use crate::{Api{{#apiInfo}}{{#apis}}{{#operations}}{{#operation}},
     {{{operationId}}}Response{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}
     };

{{#hasCallbacks}}
pub mod callbacks;

{{/hasCallbacks}}
/// Convert input into a base path, e.g. "http://example:123". Also checks the scheme as it goes.
fn into_base_path(input: impl TryInto<Uri, Error=hyper::http::uri::InvalidUri>, correct_scheme: Option<&'static str>) -> Result<String, ClientInitError> {
    // First convert to Uri, since a base path is a subset of Uri.
    let uri = input.try_into()?;

    let scheme = uri.scheme_str().ok_or(ClientInitError::InvalidScheme)?;

    // Check the scheme if necessary
    if let Some(correct_scheme) = correct_scheme {
        if scheme != correct_scheme {
            return Err(ClientInitError::InvalidScheme);
        }
    }

    let host = uri.host().ok_or(ClientInitError::MissingHost)?;
    let port = uri.port_u16().map(|x| format!(":{}", x)).unwrap_or_default();
    Ok(format!("{}://{}{}{}", scheme, host, port, uri.path().trim_end_matches('/')))
}

/// A client that implements the API by making HTTP calls out to a server.
pub struct Client<S, C> where
    S: Service<
           (Request<Body>, C),
           Response=Response<Body>> + Clone + Sync + Send + 'static,
    S::Future: Send + 'static,
    S::Error: Into<crate::ServiceError> + fmt::Display,
    C: Clone + Send + Sync + 'static
{
    /// Inner service
    client_service: S,

    /// Base path of the API
    base_path: String,

    /// Marker
    marker: PhantomData<fn(C)>,
}

impl<S, C> fmt::Debug for Client<S, C> where
    S: Service<
           (Request<Body>, C),
           Response=Response<Body>> + Clone + Sync + Send + 'static,
    S::Future: Send + 'static,
    S::Error: Into<crate::ServiceError> + fmt::Display,
    C: Clone + Send + Sync + 'static
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Client {{ base_path: {} }}", self.base_path)
    }
}

impl<S, C> Clone for Client<S, C> where
    S: Service<
           (Request<Body>, C),
           Response=Response<Body>> + Clone + Sync + Send + 'static,
    S::Future: Send + 'static,
    S::Error: Into<crate::ServiceError> + fmt::Display,
    C: Clone + Send + Sync + 'static
{
    fn clone(&self) -> Self {
        Self {
            client_service: self.client_service.clone(),
            base_path: self.base_path.clone(),
            marker: PhantomData,
        }
    }
}

impl<Connector, C> Client<DropContextService<hyper::client::Client<Connector, Body>, C>, C> where
    Connector: hyper::client::connect::Connect + Clone + Send + Sync + 'static,
    C: Clone + Send + Sync + 'static,
{
    /// Create a client with a custom implementation of hyper::client::Connect.
    ///
    /// Intended for use with custom implementations of connect for e.g. protocol logging
    /// or similar functionality which requires wrapping the transport layer. When wrapping a TCP connection,
    /// this function should be used in conjunction with `swagger::Connector::builder()`.
    ///
    /// For ordinary tcp connections, prefer the use of `try_new_http`, `try_new_https`
    /// and `try_new_https_mutual`, to avoid introducing a dependency on the underlying transport layer.
    ///
    /// # Arguments
    ///
    /// * `base_path` - base path of the client API, i.e. "http://www.my-api-implementation.com"
    /// * `protocol` - Which protocol to use when constructing the request url, e.g. `Some("http")`
    /// * `connector` - Implementation of `hyper::client::Connect` to use for the client
    pub fn try_new_with_connector(
        base_path: &str,
        protocol: Option<&'static str>,
        connector: Connector,
    ) -> Result<Self, ClientInitError>
    {
        let client_service = hyper::client::Client::builder().build(connector);
        let client_service = DropContextService::new(client_service);

        Ok(Self {
            client_service,
            base_path: into_base_path(base_path, protocol)?,
            marker: PhantomData,
        })
    }
}

#[derive(Debug, Clone)]
pub enum HyperClient {
    Http(hyper::client::Client<hyper::client::HttpConnector, Body>),
    Https(hyper::client::Client<HttpsConnector, Body>),
}

impl Service<Request<Body>> for HyperClient {
    type Response = Response<Body>;
    type Error = hyper::Error;
    type Future = hyper::client::ResponseFuture;

    fn call(&self, req: Request<Body>) -> Self::Future {
       match self {
          HyperClient::Http(client) => client.call(req),
          HyperClient::Https(client) => client.call(req)
       }
    }
}

impl<C> Client<DropContextService<HyperClient, C>, C> where
    C: Clone + Send + Sync + 'static,
{
    /// Create an HTTP client.
    ///
    /// # Arguments
    /// * `base_path` - base path of the client API, i.e. "http://www.my-api-implementation.com"
    pub fn try_new(
        base_path: &str,
    ) -> Result<Self, ClientInitError> {
        let uri = Uri::from_str(base_path)?;

        let scheme = uri.scheme_str().ok_or(ClientInitError::InvalidScheme)?;
        let scheme = scheme.to_ascii_lowercase();

        let connector = Connector::builder();

        let client_service = match scheme.as_str() {
            "http" => {
                HyperClient::Http(hyper::client::Client::builder().build(connector.build()))
            },
            "https" => {
                let connector = connector.https()
                   .build()
                   .map_err(ClientInitError::SslError)?;
                HyperClient::Https(hyper::client::Client::builder().build(connector))
            },
            _ => {
                return Err(ClientInitError::InvalidScheme);
            }
        };

        let client_service = DropContextService::new(client_service);

        Ok(Self {
            client_service,
            base_path: into_base_path(base_path, None)?,
            marker: PhantomData,
        })
    }
}

impl<C> Client<DropContextService<hyper::client::Client<hyper::client::HttpConnector, Body>, C>, C> where
    C: Clone + Send + Sync + 'static
{
    /// Create an HTTP client.
    ///
    /// # Arguments
    /// * `base_path` - base path of the client API, i.e. "http://www.my-api-implementation.com"
    pub fn try_new_http(
        base_path: &str,
    ) -> Result<Self, ClientInitError> {
        let http_connector = Connector::builder().build();

        Self::try_new_with_connector(base_path, Some("http"), http_connector)
    }
}

#[cfg(any(target_os = "macos", target_os = "windows", target_os = "ios"))]
type HttpsConnector = hyper_tls::HttpsConnector<hyper::client::HttpConnector>;

#[cfg(not(any(target_os = "macos", target_os = "windows", target_os = "ios")))]
type HttpsConnector = hyper_openssl::HttpsConnector<hyper::client::HttpConnector>;

impl<C> Client<DropContextService<hyper::client::Client<HttpsConnector, Body>, C>, C> where
    C: Clone + Send + Sync + 'static
{
    /// Create a client with a TLS connection to the server
    ///
    /// # Arguments
    /// * `base_path` - base path of the client API, i.e. "https://www.my-api-implementation.com"
    pub fn try_new_https(base_path: &str) -> Result<Self, ClientInitError>
    {
        let https_connector = Connector::builder()
            .https()
            .build()
            .map_err(ClientInitError::SslError)?;
        Self::try_new_with_connector(base_path, Some("https"), https_connector)
    }

    /// Create a client with a TLS connection to the server using a pinned certificate
    ///
    /// # Arguments
    /// * `base_path` - base path of the client API, i.e. "https://www.my-api-implementation.com"
    /// * `ca_certificate` - Path to CA certificate used to authenticate the server
    #[cfg(not(any(target_os = "macos", target_os = "windows", target_os = "ios")))]
    pub fn try_new_https_pinned<CA>(
        base_path: &str,
        ca_certificate: CA,
    ) -> Result<Self, ClientInitError>
    where
        CA: AsRef<Path>,
    {
        let https_connector = Connector::builder()
            .https()
            .pin_server_certificate(ca_certificate)
            .build()
            .map_err(ClientInitError::SslError)?;
        Self::try_new_with_connector(base_path, Some("https"), https_connector)
    }

    /// Create a client with a mutually authenticated TLS connection to the server.
    ///
    /// # Arguments
    /// * `base_path` - base path of the client API, i.e. "https://www.my-api-implementation.com"
    /// * `ca_certificate` - Path to CA certificate used to authenticate the server
    /// * `client_key` - Path to the client private key
    /// * `client_certificate` - Path to the client's public certificate associated with the private key
    #[cfg(not(any(target_os = "macos", target_os = "windows", target_os = "ios")))]
    pub fn try_new_https_mutual<CA, K, D>(
        base_path: &str,
        ca_certificate: CA,
        client_key: K,
        client_certificate: D,
    ) -> Result<Self, ClientInitError>
    where
        CA: AsRef<Path>,
        K: AsRef<Path>,
        D: AsRef<Path>,
    {
        let https_connector = Connector::builder()
            .https()
            .pin_server_certificate(ca_certificate)
            .client_authentication(client_key, client_certificate)
            .build()
            .map_err(ClientInitError::SslError)?;
        Self::try_new_with_connector(base_path, Some("https"), https_connector)
    }
}

impl<S, C> Client<S, C> where
    S: Service<
           (Request<Body>, C),
           Response=Response<Body>> + Clone + Sync + Send + 'static,
    S::Future: Send + 'static,
    S::Error: Into<crate::ServiceError> + fmt::Display,
    C: Clone + Send + Sync + 'static
{
    /// Constructor for creating a `Client` by passing in a pre-made `hyper::service::Service` /
    /// `tower::Service`
    ///
    /// This allows adding custom wrappers around the underlying transport, for example for logging.
    pub fn try_new_with_client_service(
        client_service: S,
        base_path: &str,
    ) -> Result<Self, ClientInitError>
    {
        Ok(Self {
            client_service,
            base_path: into_base_path(base_path, None)?,
            marker: PhantomData,
        })
    }
}

/// Error type failing to create a Client
#[derive(Debug)]
pub enum ClientInitError {
    /// Invalid URL Scheme
    InvalidScheme,

    /// Invalid URI
    InvalidUri(hyper::http::uri::InvalidUri),

    /// Missing Hostname
    MissingHost,

    /// SSL Connection Error
    #[cfg(any(target_os = "macos", target_os = "windows", target_os = "ios"))]
    SslError(native_tls::Error),

    /// SSL Connection Error
    #[cfg(not(any(target_os = "macos", target_os = "windows", target_os = "ios")))]
    SslError(openssl::error::ErrorStack),
}

impl From<hyper::http::uri::InvalidUri> for ClientInitError {
    fn from(err: hyper::http::uri::InvalidUri) -> ClientInitError {
        ClientInitError::InvalidUri(err)
    }
}

impl fmt::Display for ClientInitError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let s: &dyn fmt::Debug = self;
        s.fmt(f)
    }
}

impl Error for ClientInitError {
    fn description(&self) -> &str {
        "Failed to produce a hyper client."
    }
}

#[async_trait]
impl<S, C> Api<C> for Client<S, C> where
    S: Service<
       (Request<Body>, C),
       Response=Response<Body>> + Clone + Sync + Send + 'static,
    S::Future: Send + 'static,
    S::Error: Into<crate::ServiceError> + fmt::Display,
    C: Has<XSpanIdString> {{#hasAuthMethods}}+ Has<Option<AuthData>>{{/hasAuthMethods}} + Clone + Send + Sync + 'static,
{
    fn poll_ready(&self, cx: &mut Context) -> Poll<Result<(), crate::ServiceError>> {
        match self.client_service.clone().poll_ready(cx) {
            Poll::Ready(Err(e)) => Poll::Ready(Err(e.into())),
            Poll::Ready(Ok(o)) => Poll::Ready(Ok(o)),
            Poll::Pending => Poll::Pending,
        }
    }

{{#apiInfo}}
  {{#apis}}
    {{#operations}}
      {{#operation}}
{{>client-operation}}
      {{/operation}}
    {{/operations}}
  {{/apis}}
{{/apiInfo}}
}
client-operation.mustache:
    async fn {{#vendorExtensions}}{{{x-operation-id}}}{{/vendorExtensions}}(
        &self,
{{#vendorExtensions}}
  {{#x-callback-params}}
        callback_{{.}}: String,
  {{/x-callback-params}}
{{/vendorExtensions}}
{{#allParams}}
        param_{{{paramName}}}: {{^required}}Option<{{/required}}{{#isArray}}&{{/isArray}}{{{dataType}}}{{^required}}>{{/required}},
{{/allParams}}
        context: &C) -> Result<{{{operationId}}}Response, ApiError>
    {
        let mut client_service = self.client_service.clone();
        let mut uri = format!(
{{#isCallbackRequest}}
            "{{vendorExtensions.x-path-format-string}}"
{{/isCallbackRequest}}
{{^isCallbackRequest}}
            "{}{{^servers}}{{{basePathWithoutHost}}}{{/servers}}{{#servers.0}}{{{url}}}{{/servers.0}}{{vendorExtensions.x-path-format-string}}",
            self.base_path
{{/isCallbackRequest}}
{{#pathParams}}
            ,{{{paramName}}}=utf8_percent_encode(&param_{{{paramName}}}.to_string(), ID_ENCODE_SET)
{{/pathParams}}
{{#vendorExtensions}}
  {{#x-callback-params}}
            ,{{.}}=callback_{{.}}
  {{/x-callback-params}}
{{/vendorExtensions}}
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
{{#queryParams}}
  {{^required}}
            if let Some(param_{{{paramName}}}) = param_{{{paramName}}} {
  {{/required}}
                query_string.append_pair("{{{baseName}}}",
  {{#vendorExtensions}}
    {{#x-consumes-json}}
                    &match serde_json::to_string(&param_{{{paramName}}}) {
                        Ok(str) => str,
                        Err(e) => return Err(ApiError(format!("Unable to serialize {{{paramName}}} to string: {}", e))),
                    });
    {{/x-consumes-json}}
    {{^x-consumes-json}}
      {{#isArray}}
                    &param_{{{paramName}}}.iter().map(ToString::to_string).collect::<Vec<String>>().join(","));
      {{/isArray}}
      {{^isArray}}
                    &param_{{{paramName}}}{{^isString}}.to_string(){{/isString}});
      {{/isArray}}
    {{/x-consumes-json}}
  {{/vendorExtensions}}
  {{^required}}
            }
  {{/required}}
{{/queryParams}}
{{#authMethods}}
  {{#isApiKey}}
    {{#isKeyInQuery}}
            if let Some(AuthData::ApiKey(ref api_key)) = (context as &dyn Has<Option<AuthData>>).get().as_ref() {
                query_string.append_pair("{{keyParamName}}", api_key);
            }
    {{/isKeyInQuery}}
  {{/isApiKey}}
{{/authMethods}}
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {}", err))),
        };

        let mut request = match Request::builder()
            .method("{{{vendorExtensions.x-http-method}}}")
            .uri(uri)
            .body(Full::new(Bytes::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {}", e)))
        };
{{>client-request-body-instance}}
        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {}", e)))
        });

{{#hasAuthMethods}}
        #[allow(clippy::collapsible_match)]
        if let Some(auth_data) = Has::<Option<AuthData>>::get(context).as_ref() {
            {{! Currently only authentication with Basic and Bearer are supported }}
            #[allow(clippy::single_match, clippy::match_single_binding)]
            match auth_data {
            {{#authMethods}}
                {{#isBasicBasic}}
                AuthData::Basic(basic_header) => {
                    let auth = swagger::auth::Header(basic_header.clone());
                    let header = match HeaderValue::from_str(&format!("{}", auth)) {
                        Ok(h) => h,
                        Err(e) => return Err(ApiError(format!("Unable to create Authorization header: {}", e)))
                    };
                    request.headers_mut().insert(
                        hyper::header::AUTHORIZATION,
                        header);
                },
                {{/isBasicBasic}}
                {{#isBasicBearer}}
                AuthData::Bearer(bearer_header) => {
                    let auth = swagger::auth::Header(bearer_header.clone());
                    let header = match HeaderValue::from_str(&format!("{}", auth)) {
                        Ok(h) => h,
                        Err(e) => return Err(ApiError(format!("Unable to create Authorization header: {}", e)))
                    };
                    request.headers_mut().insert(
                        hyper::header::AUTHORIZATION,
                        header);
                },
                {{/isBasicBearer}}
                {{#isOAuth}}
                {{^isBasicBearer}}
                AuthData::Bearer(bearer_header) => {
                    let auth = swagger::auth::Header(bearer_header.clone());
                    let header = match HeaderValue::from_str(&format!("{}", auth)) {
                        Ok(h) => h,
                        Err(e) => return Err(ApiError(format!("Unable to create Authorization header: {}", e)))
                    };
                    request.headers_mut().insert(
                        hyper::header::AUTHORIZATION,
                        header);
                },
                {{/isBasicBearer}}
                {{/isOAuth}}
            {{/authMethods}}
                _ => {}
            }
        }

{{/hasAuthMethods}}
{{#headerParams}}
{{#-first}}
        // Header parameters
{{/-first}}
{{^isMap}}
{{^required}}
        #[allow(clippy::single_match)]
        match param_{{{paramName}}} {
            Some(param_{{{paramName}}}) => {
{{/required}}
        request.headers_mut().append(
            HeaderName::from_static("{{{nameInLowerCase}}}"),
            #[allow(clippy::redundant_clone)]
            match header::IntoHeaderValue(param_{{{paramName}}}.clone()).try_into() {
                Ok(header) => header,
                Err(e) => {
                    return Err(ApiError(format!(
                        "Invalid header {{{paramName}}} - {}", e)));
                },
            });
{{^required}}
            },
            None => {}
        }
{{/required}}
{{/isMap}}
{{#isMap}}
        let param_{{{paramName}}}: Option<{{{dataType}}}> = None;
{{/isMap}}

{{/headerParams}}
        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {}", e))).await?;

        match response.status().as_u16() {
{{#responses}}
            {{{code}}} => {
{{#headers}}
                let response_{{{name}}} = match response.headers().get(HeaderName::from_static("{{{nameInLowerCase}}}")) {
                    Some(response_{{{name}}}) => {
                        let response_{{{name}}} = response_{{{name}}}.clone();
                        let response_{{{name}}} = match TryInto::<header::IntoHeaderValue<{{{dataType}}}>>::try_into(response_{{{name}}}) {
                            Ok(value) => value,
                            Err(e) => {
                                return Err(ApiError(format!("Invalid response header {{baseName}} for response {{code}} - {}", e)));
                            },
                        };
  {{#required}}
                        response_{{{name}}}.0
  {{/required}}
  {{^required}}
                        Some(response_{{{name}}}.0)
  {{/required}}
                        },
  {{#required}}
                    None => return Err(ApiError(String::from("Required response header {{{baseName}}} for response {{{code}}} was not found."))),
  {{/required}}
  {{^required}}
                    None => None,
  {{/required}}
                };

{{/headers}}
{{#dataType}}
                let body = response.into_body();
                let body = body
                        .into_raw()
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e))).await?;

{{>client-response-body-instance}}

                Ok({{{operationId}}}Response::{{#vendorExtensions}}{{x-response-id}}{{/vendorExtensions}}
{{^headers}}
                    (body)
{{/headers}}
{{#headers}}
  {{#-first}}
                    {
                        body,
  {{/-first}}
                        {{{name}}}: response_{{name}},
  {{#-last}}
                    }
  {{/-last}}
{{/headers}}
                )
{{/dataType}}
{{^dataType}}
                Ok(
                    {{{operationId}}}Response::{{#vendorExtensions}}{{x-response-id}}{{/vendorExtensions}}
{{#headers}}
  {{#-first}}
                    {
  {{/-first}}
                        {{{name}}}: response_{{name}},
  {{#-last}}
                    }
  {{/-last}}
{{/headers}}
                )
{{/dataType}}
            }
{{/responses}}
            code => {
                let headers = response.headers().clone();
                let body = response.into_body()
                       .take(100)
                       .into_raw().await;
                Err(ApiError(format!("Unexpected response code {}:\n{:?}\n\n{}",
                    code,
                    headers,
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {:?}>", e),
                        },
                        Err(e) => format!("<Failed to read body: {}>", e),
                    }
                )))
            }
        }
    }
client-request-body-instance.mustache:
{{#vendorExtensions}}
  {{#x-consumes-multipart-form}}

        // Consumes multipart/form body
{{>client-request-body-multipart-form}}
  {{/x-consumes-multipart-form}}
  {{#x-consumes-multipart-related}}

        // Consumes multipart/related body
    {{#formParams}}
{{>generate-multipart-related}}
    {{/formParams}}

        let header = "multipart/related";
        request.headers_mut().insert(CONTENT_TYPE,
        match HeaderValue::from_bytes(
            &[header.as_bytes(), "; boundary=".as_bytes(), &boundary, "; type=\"application/json\"".as_bytes()].concat()
        ) {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create header: {} - {}", header, e)))
        });

        // Add the message body to the request object.
        *request.body_mut() = Full::new(Bytes::from(body));
  {{/x-consumes-multipart-related}}
  {{#x-consumes-form}}

        // Consumes form body
    {{#formParams}}
      {{#-first}}
        let mut params = vec![];
      {{/-first}}
      {{^required}}
        if let Some(param_{{{paramName}}}) = param_{{{paramName}}} {
      {{/required}}
      {{#isArray}}
        // style=form,explode=true
        for param_{{{paramName}}} in param_{{{paramName}}} {
      {{/isArray}}
        params.push(("{{{baseName}}}",
      {{^isString}}
            format!("{{{vendorExtensions.x-format-string}}}", param_{{{paramName}}})
      {{/isString}}
      {{#isString}}
        {{#isArray}}
            param_{{{paramName}}}.to_string()
        {{/isArray}}
        {{^isArray}}
            param_{{{paramName}}}
        {{/isArray}}
      {{/isString}}
        ));
      {{#isArray}}
        }
      {{/isArray}}
      {{^required}}
        }
      {{/required}}
      {{#-last}}

        let body = serde_urlencoded::to_string(params).expect("impossible to fail to serialize");

        *request.body_mut() = Full::new(Bytes::from(body.into_bytes()));

        let header = "{{#consumes}}{{#-first}}{{{mediaType}}}{{/-first}}{{/consumes}}{{^consumes}}application/json{{/consumes}}";
        request.headers_mut().insert(CONTENT_TYPE, match HeaderValue::from_str(header) {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create header: {} - {}", header, e)))
        });
      {{/-last}}
    {{/formParams}}
  {{/x-consumes-form}}
  {{#x-consumes-basic}}

        // Consumes basic body
    {{#bodyParam}}
        // Body parameter
      {{^required}}
        if let Some(param_{{{paramName}}}) = param_{{{paramName}}} {
      {{/required}}
      {{#vendorExtensions}}
        {{#x-consumes-plain-text}}
          {{#isByteArray}}
        let body = param_{{{paramName}}}.0;
          {{/isByteArray}}
          {{^isByteArray}}
        let body = param_{{{paramName}}};
          {{/isByteArray}}
        {{/x-consumes-plain-text}}
        {{#x-consumes-xml}}
        let body = param_{{{paramName}}}.as_xml();
        {{/x-consumes-xml}}
        {{#x-consumes-json}}
        let body = serde_json::to_string(&param_{{{paramName}}}).expect("impossible to fail to serialize");
        {{/x-consumes-json}}
      {{/vendorExtensions}}
        *request.body_mut() = Full::new(Bytes::from(body));
      {{^required}}
        }
      {{/required}}

        let header = "{{#consumes}}{{#-first}}{{{mediaType}}}{{/-first}}{{/consumes}}{{^consumes}}application/json{{/consumes}}";
        request.headers_mut().insert(CONTENT_TYPE, match HeaderValue::from_str(header) {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create header: {} - {}", header, e)))
        });
    {{/bodyParam}}
  {{/x-consumes-basic}}
{{/vendorExtensions}}
client-request-body-multipart-form.mustache:
        let (body_string, multipart_header) = {
            let mut multipart = Multipart::new();

    {{#vendorExtensions}}
      {{#formParams}}
        {{#-first}}
            // For each parameter, encode as appropriate and add to the multipart body as a stream.
        {{/-first}}

        {{^isByteArray}}
          {{#jsonSchema}}
            let {{{paramName}}}_str = match serde_json::to_string(&param_{{{paramName}}}) {
                Ok(str) => str,
                Err(e) => return Err(ApiError(format!("Unable to serialize {{{paramName}}} to string: {}", e))),
            };

            let {{{paramName}}}_vec = {{{paramName}}}_str.as_bytes().to_vec();
            let {{{paramName}}}_mime = mime_0_2::Mime::from_str("application/json").expect("impossible to fail to parse");
            let {{{paramName}}}_cursor = Cursor::new({{{paramName}}}_vec);

            multipart.add_stream("{{{paramName}}}",  {{{paramName}}}_cursor,  None as Option<&str>, Some({{{paramName}}}_mime));
          {{/jsonSchema}}
        {{/isByteArray}}

        {{#isByteArray}}
            let {{{paramName}}}_vec = param_{{{paramName}}}.to_vec();

            let {{{paramName}}}_mime = match mime_0_2::Mime::from_str("application/octet-stream") {
                Ok(mime) => mime,
                Err(err) => return Err(ApiError(format!("Unable to get mime type: {:?}", err))),
            };

            let {{{paramName}}}_cursor = Cursor::new({{{paramName}}}_vec);

            let filename = None as Option<&str> ;
            multipart.add_stream("{{{paramName}}}",  {{{paramName}}}_cursor,  filename, Some({{{paramName}}}_mime));
        {{/isByteArray}}
      {{/formParams}}
    {{/vendorExtensions}}

            let mut fields = match multipart.prepare() {
                Ok(fields) => fields,
                Err(err) => return Err(ApiError(format!("Unable to build request: {}", err))),
            };

            let mut body_string = String::new();

            match fields.read_to_string(&mut body_string) {
                Ok(_) => (),
                Err(err) => return Err(ApiError(format!("Unable to build body: {}", err))),
            }

            let boundary = fields.boundary();

            let multipart_header = format!("multipart/form-data;boundary={}", boundary);

            (body_string, multipart_header)
        };

        *request.body_mut() = Body::from(body_string);

        request.headers_mut().insert(CONTENT_TYPE, match HeaderValue::from_str(&multipart_header) {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create header: {} - {}", multipart_header, e)))
        });
client-response-body-instance.mustache:
{{#vendorExtensions}}
  {{#x-produces-bytes}}
                let body = swagger::ByteArray(body.to_vec());
  {{/x-produces-bytes}}
  {{^x-produces-bytes}}
                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {}", e)))?;
    {{#x-produces-xml}}
                // ToDo: this will move to swagger-rs and become a standard From conversion trait
                // once https://github.com/RReverser/serde-xml-rs/pull/45 is accepted upstream
                let body = serde_xml_rs::from_str::<{{{dataType}}}>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {}", e)))?;
    {{/x-produces-xml}}
    {{#x-produces-json}}
                let body = serde_json::from_str::<{{{dataType}}}>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {}", e)))?;
    {{/x-produces-json}}
    {{#x-produces-plain-text}}
                let body = body.to_string();
    {{/x-produces-plain-text}}
  {{/x-produces-bytes}}
{{/vendorExtensions}}
client-response-body-multipart-related.mustache:
// Create headers from top-level content type header.
let multipart_headers = match swagger::multipart::related::create_multipart_headers(header.headers.get(CONTENT_TYPE)) {
    Ok(headers) => headers,
    Err(e) => {
        return Err(ApiError(e));
    }
};

// &*body expresses the body as a byteslice, &mut provides a
// mutable reference to that byteslice.
let nodes = match read_multipart_body(&mut&*body, &multipart_headers, false) {
    Ok(nodes) => nodes,
    Err(e) => {
        return Err(ApiError(format!("Could not read multipart body for {{operationId}}: {}", e)));
    }
};

{{#formParams}}
let mut param_{{{paramName}}} = None;
{{/formParams}}

for node in nodes {
    if let Node::Part(part) = node {
        let content_type = part.content_type().map(|x| format!("{}",x));
        match content_type.as_ref().map(|x| x.as_str()) {
{{#formParams}}
  {{^isBinary}}
            Some("{{{contentType}}}") if param_{{{paramName}}}.is_none() => {
                // Extract JSON part.
                let deserializer = &mut serde_json::Deserializer::from_slice(part.body.as_slice());
                let json_data: {{{dataType}}} = match serde_ignored::deserialize(deserializer, |path| {
                    warn!("Ignoring unknown field in JSON part: {}", path);
                }) {
                    Ok(json_data) => json_data,
                    Err(e) => return Err(ApiError(format!("Couldn't parse body parameter {{dataType}} - doesn't match schema: {}", e)))
                };
                // Push JSON part to return object.
                param_{{{paramName}}}.get_or_insert(json_data);
            },
  {{/isBinary}}
  {{#isBinary}}
            Some("{{{contentType}}}") if param_{{{paramName}}}.is_none() => {
                param_{{{paramName}}}.get_or_insert(swagger::ByteArray(part.body));
            },
  {{/isBinary}}
{{/formParams}}
            Some(content_type) => {
                warn!("Ignoring unexpected content type: {}", content_type);
            },
            None => {
                warn!("Missing content type");
            },
        }
    } else {
        return Err(ApiError(format!("Unexpected part in multipart body for {{operationId}}: {:?}", node)));
    }
}
{{#formParams}}
  {{#-first}}

// Check that the required multipart chunks are present.
  {{/-first}}
  {{#required}}
let param_{{{paramName}}} = match param_{{{paramName}}} {
    Some(x) => x,
    None => return Err(ApiError("Missing required multipart/related parameter {{{paramName}}}"))
};
  {{/required}}
{{/formParams}}
  {{^vendorExtensions.x-consumes-basic}}
              let body = {{{dataType}}} {
    {{#formParams}}
                  {{{paramName}}}: param_{{{paramName}}},
    {{/formParams}}
              };
  {{/vendorExtensions.x-consumes-basic}}
context.mustache:
use futures::future::BoxFuture;
use hyper::header::HeaderName;
use hyper::{Error, Request, Response, StatusCode, service::Service};
use url::form_urlencoded;
use std::default::Default;
use std::io;
use std::marker::PhantomData;
use std::task::{Poll, Context};
use swagger::auth::{AuthData, Authorization, Bearer, Scopes};
// use swagger::{EmptyContext, Has, Pop, Push, XSpanIdString};
use crate::{Api, AuthenticationApi};
use log::error;

pub struct MakeAddContext<T, A> {
    inner: T,
    marker: PhantomData<A>,
}

impl<T, A, B, C, D> MakeAddContext<T, A>
where
    A: Default + Push<XSpanIdString, Result = B>,
    B: Push<Option<AuthData>, Result = C>,
    C: Push<Option<Authorization>, Result = D>,
{
    pub fn new(inner: T) -> MakeAddContext<T, A> {
        MakeAddContext {
            inner,
            marker: PhantomData,
        }
    }
}

// Make a service that adds context.
impl<Target, T, A, B, C, D> Service<Target> for
    MakeAddContext<T, A>
where
    Target: Send,
    A: Default + Push<XSpanIdString, Result = B> + Send,
    B: Push<Option<AuthData>, Result = C>,
    C: Push<Option<Authorization>, Result = D>,
    D: Send + 'static,
    T: Service<Target> + Send,
    T::Future: Send + 'static
{
    type Error = T::Error;
    type Response = AddContext<T::Response, A, B, C, D>;
    type Future = BoxFuture<'static, Result<Self::Response, Self::Error>>;

    fn call(&self, target: Target) -> Self::Future {
        let service = self.inner.call(target);

        Box::pin(async move {
            Ok(AddContext::new(service.await?))
        })
    }
}

/// Middleware to add context data from the request
pub struct AddContext<T, A, B, C, D>
where
    A: Default + Push<XSpanIdString, Result = B>,
    B: Push<Option<AuthData>, Result = C>,
    C: Push<Option<Authorization>, Result = D>
{
    inner: T,
    marker: PhantomData<A>,
}

impl<T, A, B, C, D> AddContext<T, A, B, C, D>
where
    A: Default + Push<XSpanIdString, Result = B>,
    B: Push<Option<AuthData>, Result = C>,
    C: Push<Option<Authorization>, Result = D>,
{
    pub fn new(inner: T) -> Self {
        AddContext {
            inner,
            marker: PhantomData,
        }
    }
}

impl<T, A, B, C, D, ReqBody> Service<Request<ReqBody>> for AddContext<T, A, B, C, D>
    where
        A: Default + Push<XSpanIdString, Result=B>,
        B: Push<Option<AuthData>, Result=C>,
        C: Push<Option<Authorization>, Result=D>,
        D: Send + 'static,
        T: Service<(Request<ReqBody>, D)> + AuthenticationApi
{
    type Error = T::Error;
    type Future = T::Future;
    type Response = T::Response;

    fn call(&self, request: Request<ReqBody>) -> Self::Future {
        let context = A::default().push(XSpanIdString::get_or_generate(&request));
        let headers = request.headers();

        {{#authMethods}}
        {{#isBasic}}
        {{#isBasicBasic}}
        {
            use swagger::auth::Basic;
            use std::ops::Deref;
            if let Some(basic) = swagger::auth::from_headers::<Basic>(headers) {
                let authorization = self.inner.basic_authorization(&basic);
                let auth_data = AuthData::Basic(basic);

                let context = context.push(Some(auth_data));
                let context = match authorization {
                    Ok(auth) => context.push(Some(auth)),
                    Err(err) => {
                        error!("Error during Authorization: {err:?}");
                        context.push(None::<Authorization>)
                    }
                };

                return self.inner.call((request, context))
            }
        }
        {{/isBasicBasic}}
        {{#isBasicBearer}}
        {
            use swagger::auth::Bearer;
            use std::ops::Deref;
            if let Some(bearer) = swagger::auth::from_headers::<Bearer>(headers) {
                let authorization = self.inner.bearer_authorization(&bearer);
                let auth_data = AuthData::Bearer(bearer);

                let context = context.push(Some(auth_data));
                let context = match authorization {
                    Ok(auth) => context.push(Some(auth)),
                    Err(err) => {
                        error!("Error during Authorization: {err:?}");
                        context.push(None::<Authorization>)
                    }
                };

                return self.inner.call((request, context))
            }
        }
        {{/isBasicBearer}}
        {{/isBasic}}
        {{#isOAuth}}
        {
            use swagger::auth::Bearer;
            use std::ops::Deref;
            if let Some(bearer) = swagger::auth::from_headers::<Bearer>(headers) {
                let authorization = self.inner.bearer_authorization(&bearer);
                let auth_data = AuthData::Bearer(bearer);

                let context = context.push(Some(auth_data));
                let context = match authorization {
                    Ok(auth) => context.push(Some(auth)),
                    Err(err) => {
                        error!("Error during Authorization: {err:?}");
                        context.push(None::<Authorization>)
                    }
                };

                return self.inner.call((request, context))
            }
        }
        {{/isOAuth}}
        {{#isApiKey}}
        {{#isKeyInHeader}}
        {
            use swagger::auth::api_key_from_header;

            if let Some(header) = api_key_from_header(headers, "{{{keyParamName}}}") {
                let authorization = self.inner.apikey_authorization(&header);
                let auth_data = AuthData::ApiKey(header);

                let context = context.push(Some(auth_data));
                let context = match authorization {
                    Ok(auth) => context.push(Some(auth)),
                    Err(err) => {
                        error!("Error during Authorization: {err:?}");
                        context.push(None::<Authorization>)
                    }
                };

                return self.inner.call((request, context))
            }
        }
        {{/isKeyInHeader}}
        {{#isKeyInQuery}}
        {
            let key = form_urlencoded::parse(request.uri().query().unwrap_or_default().as_bytes())
                .filter(|e| e.0 == "{{{keyParamName}}}")
                .map(|e| e.1.clone().into_owned())
                .next();
            if let Some(key) = key {
                let authorization = self.inner.apikey_authorization(&key);
                let auth_data = AuthData::ApiKey(key);

                let context = context.push(Some(auth_data));
                let context = match authorization {
                    Ok(auth) => context.push(Some(auth)),
                    Err(err) => {
                        error!("Error during Authorization: {err:?}");
                        context.push(None::<Authorization>)
                    }
                };

                return self.inner.call((request, context))
            }
        }
        {{/isKeyInQuery}}
        {{/isApiKey}}
        {{/authMethods}}

        let context = context.push(None::<AuthData>);
        let context = context.push(None::<Authorization>);

        self.inner.call((request, context))
    }
}
example-ca.pem:
-----BEGIN CERTIFICATE-----
MIICtjCCAZ4CCQDpKecRERZ0xDANBgkqhkiG9w0BAQsFADAdMQswCQYDVQQGEwJV
UzEOMAwGA1UEAxMFTXkgQ0EwHhcNMTcwNTIzMTYwMDIzWhcNMTcwNjIyMTYwMDIz
WjAdMQswCQYDVQQGEwJVUzEOMAwGA1UEAxMFTXkgQ0EwggEiMA0GCSqGSIb3DQEB
AQUAA4IBDwAwggEKAoIBAQCt66py3x7sCSASRF2D05L5wkNDxAUjQKYx23W8Gbwv
GMGykk89BIdU5LX1JB1cKiUOkoIxfwAYuWc2V/wzTvVV7+11besnk3uX1c9KiqUF
LIX7kn/z5hzS4aelhKvH+MJlSZCSlp1ytpZbwo5GB5Pi2SGH56jDBiBoDRNBVdWL
z4wH7TdrQjqWwNxIZumD5OGMtcfJyuX08iPiEOaslOeoMqzObhvjc9aUgjVjhqyA
FkJGTXsi0oaD7oml+NE+mTNfEeZvEJQpLSjBY0OvQHzuHkyGBShBnfu/9x7/NRwd
WaqsLiF7/re9KDGYdJwP7Cu6uxYfKAyWarp6h2mG/GIdAgMBAAEwDQYJKoZIhvcN
AQELBQADggEBAGIl/VVIafeq/AJOQ9r7TzzB2ABJYr7NZa6bTu5O1jSp1Fonac15
SZ8gvRxODgH22ZYSqghPG4xzq4J3hkytlQqm57ZEt2I2M3OqIp17Ndcc1xDYzpLl
tA0FrVn6crQTM8vQkTDtGesaCWX+7Fir5dK7HnYWzfpSmsOpST07PfbNisEXKOxG
Dj4lBL1OnhTjsJeymVS1pFvkKkrcEJO+IxFiHL3CDsWjcXB0Z+E1zBtPoYyYsNsO
rBrjUxcZewF4xqWZhpW90Mt61fY2nRgU0uUwHcvDQUqvmzKcsqYa4mPKzfBI5mxo
01Ta96cDD6pS5Y1hOflZ0g84f2g/7xBLLDA=
-----END CERTIFICATE-----
example-client-auth.mustache:
use {{{externCrateName}}}::Claims;
use jsonwebtoken::{encode, errors::Error as JwtError, Algorithm, EncodingKey, Header};
use log::debug;

/// build an encrypted token with the provided claims.
pub fn build_token(my_claims: Claims, key: &[u8]) -> Result<String, JwtError> {

    // Ensure that you set the correct algorithm and correct key.
    // See https://github.com/Keats/jsonwebtoken for more information.
    let header =
        Header { kid: Some("signing_key".to_owned()), alg: Algorithm::HS512, ..Default::default() };

    let token = encode(&header, &my_claims, &EncodingKey::from_secret(key))?;
    debug!("Derived token: {:?}", token);

    Ok(token)
}
example-client-main.mustache:
#![allow(missing_docs, unused_variables, trivial_casts)]

{{#hasCallbacks}}
mod server;
{{/hasCallbacks}}

#[allow(unused_imports)]
use futures::{future, Stream, stream};
#[allow(unused_imports)]
use {{{externCrateName}}}::{Api, ApiNoContext, Claims, Client, ContextWrapperExt, models,
{{#apiInfo}}
  {{#apis}}
    {{#operations}}
      {{#operation}}
                      {{{operationId}}}Response,
      {{/operation}}
    {{/operations}}
  {{/apis}}
{{/apiInfo}}
                     };
use clap::{App, Arg};

// NOTE: Set environment variable RUST_LOG to the name of the executable (or "cargo run") to activate console logging for all loglevels.
//     See https://docs.rs/env_logger/latest/env_logger/  for more details

#[allow(unused_imports)]
use log::info;

// swagger::Has may be unused if there are no examples
#[allow(unused_imports)]
use swagger::{AuthData, ContextBuilder, EmptyContext, Has, Push, XSpanIdString};

type ClientContext = swagger::make_context_ty!(ContextBuilder, EmptyContext, Option<AuthData>, XSpanIdString);

mod client_auth;
use client_auth::build_token;


// rt may be unused if there are no examples
#[allow(unused_mut)]
fn main() {
    env_logger::init();

    let matches = App::new("client")
        .arg(Arg::with_name("operation")
            .help("Sets the operation to run")
            .possible_values(&[
{{#apiInfo}}
  {{#apis}}
    {{#operations}}
      {{#operation}}
        {{#vendorExtensions}}
          {{^x-no-client-example}}
                "{{{operationId}}}",
          {{/x-no-client-example}}
        {{/vendorExtensions}}
      {{/operation}}
    {{/operations}}
  {{/apis}}
{{/apiInfo}}
            ])
            .required(true)
            .index(1))
        .arg(Arg::with_name("https")
            .long("https")
            .help("Whether to use HTTPS or not"))
        .arg(Arg::with_name("host")
            .long("host")
            .takes_value(true)
            .default_value("{{{serverHost}}}")
            .help("Hostname to contact"))
        .arg(Arg::with_name("port")
            .long("port")
            .takes_value(true)
            .default_value("{{{serverPort}}}")
            .help("Port to contact"))
        .get_matches();

    // Create Bearer-token with a fixed key (secret) for test purposes.
    // In a real (production) system this Bearer token should be obtained via an external Identity/Authentication-server
    // Ensure that you set the correct algorithm and encodingkey that matches what is used on the server side.
    // See https://github.com/Keats/jsonwebtoken for more information
    let auth_token = build_token(
            Claims {
                sub: "tester@acme.com".to_owned(),
                company: "ACME".to_owned(),
                iss: "my_identity_provider".to_owned(),
                // added a very long expiry time
                aud: "org.acme.Resource_Server".to_string(),
                exp: 10000000000,
                // In this example code all available Scopes are added, so the current Bearer Token gets fully authorization.
                scopes:
                {{#hasAuthScopes}}
                  [
                    {{#authMethods}}
                      {{#scopes}}
                            "{{{scope}}}",
                      {{/scopes}}
                    {{/authMethods}}
                  ].join::<&str>(", ")
                {{/hasAuthScopes}}
                {{^hasAuthScopes}}
                  "".to_owned()
                {{/hasAuthScopes}}
            },
            b"secret").unwrap();

    let auth_data = if !auth_token.is_empty() {
        Some(AuthData::Bearer(swagger::auth::Bearer { token: auth_token}))
    } else {
        // No Bearer-token available, so return None
        None
    };

    let is_https = matches.is_present("https");
    let base_url = format!("{}://{}:{}",
        if is_https { "https" } else { "http" },
        matches.value_of("host").unwrap(),
        matches.value_of("port").unwrap());

    let context: ClientContext =
        swagger::make_context!(ContextBuilder, EmptyContext, auth_data, XSpanIdString::default());

    let mut client : Box<dyn ApiNoContext<ClientContext>> = if matches.is_present("https") {
        // Using Simple HTTPS
        let client = Box::new(Client::try_new_https(&base_url)
            .expect("Failed to create HTTPS client"));
        Box::new(client.with_context(context))
    } else {
        // Using HTTP
        let client = Box::new(Client::try_new_http(
            &base_url)
            .expect("Failed to create HTTP client"));
        Box::new(client.with_context(context))
    };

    let mut rt = tokio::runtime::Runtime::new().unwrap();
{{#hasCallbacks}}

    // We could do HTTPS here, but for simplicity we don't
    rt.spawn(server::create("127.0.0.1:8081", false));
{{/hasCallbacks}}

    match matches.value_of("operation") {
{{#apiInfo}}
  {{#apis}}
    {{#operations}}
      {{#operation}}
        {{#vendorExtensions}}
          {{#x-no-client-example}}
        /* Disabled because there's no example.
          {{/x-no-client-example}}
        {{/vendorExtensions}}
        Some("{{{operationId}}}") => {
            let result = rt.block_on(client.{{{vendorExtensions.x-operation-id}}}(
                {{#allParams}}
                  {{{vendorExtensions.x-example}}}{{^-last}},{{/-last}}
                {{/allParams}}
            ));
            info!("{:?} (X-Span-ID: {:?})", result, (client.context() as &dyn Has<XSpanIdString>).get().clone());
        },
        {{#vendorExtensions}}
          {{#x-no-client-example}}
        */
          {{/x-no-client-example}}
        {{/vendorExtensions}}
      {{/operation}}
    {{/operations}}
  {{/apis}}
{{/apiInfo}}
        _ => {
            panic!("Invalid operation provided")
        }
    }
}
example-client-server.mustache:
{{>example-server-common}}
use {{{externCrateName}}}::CallbackApi;
{{#apiInfo}}
  {{#apis}}
    {{#operations}}
      {{#operation}}
        {{#callbacks}}
          {{#urls}}
            {{#requests}}
use {{{externCrateName}}}::{{{operationId}}}Response;
            {{/requests}}
          {{/urls}}
        {{/callbacks}}
      {{/operation}}
    {{/operations}}
  {{/apis}}
{{/apiInfo}}
use {{{externCrateName}}}::client::callbacks::MakeService;
use std::error::Error;
use swagger::ApiError;

#[async_trait]
impl<C> CallbackApi<C> for Server<C> where C: Has<XSpanIdString> + Send + Sync
{
{{#apiInfo}}
  {{#apis}}
    {{#operations}}
      {{#operation}}
        {{#callbacks}}
          {{#urls}}
            {{#requests}}
{{>example-server-operation}}
            {{/requests}}
          {{/urls}}
        {{/callbacks}}
      {{/operation}}
    {{/operations}}
  {{/apis}}
{{/apiInfo}}
}
example-server-auth.mustache:
use swagger::{
    ApiError,
    auth::{Basic, Bearer},
    Has,
    XSpanIdString};
use {{{externCrateName}}}::{AuthenticationApi, Claims};
use crate::server::Server;
use jsonwebtoken::{decode, errors as JwtError, decode_header, DecodingKey, TokenData, Validation};
use swagger::auth::Authorization;
use log::{error, debug};

// NOTE: Set environment variable RUST_LOG to the name of the executable (or "cargo run") to activate console logging for all loglevels.
//     See https://docs.rs/env_logger/latest/env_logger/  for more details


/// Get a dummy claim with full permissions (all scopes) for testing purposes
fn full_permission_claim() -> Claims {
    // In this example code all available Scopes are added, so the current Bearer Token gets fully authorization.
    Claims {
        sub: "tester@acme.com".to_owned(),
        company: "ACME".to_owned(),
        iss: "mini-bank-IDP".to_owned(),
        aud: "org.acme.Resource_Server".to_string(),
        // added a very long expiry time
        exp: 10000000000,
        scopes:
        {{#hasAuthScopes}}
          [
            {{#authMethods}}
              {{#scopes}}
                    "{{{scope}}}",
              {{/scopes}}
            {{/authMethods}}
          ].join::<&str>(", ")
        {{/hasAuthScopes}}
        {{^hasAuthScopes}}
          "".to_owned()
        {{/hasAuthScopes}}
    }
}



/// Extract the data from a Bearer token using the provided Key (secret) and using the HS512-algorithm in this example.
fn extract_token_data(token: &str, key: &[u8]) -> Result<TokenData<Claims>, JwtError::Error> {

    // Ensure that you set the correct algorithm and correct key.
    // See https://github.com/Keats/jsonwebtoken for more information.
    let header = decode_header(token)?;
    let validation = {
        let mut validation = Validation::new(header.alg);
        validation.set_audience(&["org.acme.Resource_Server"]);
        validation.validate_exp = true;
        validation
    };

    let token_data = decode::<Claims>(
        &token,
        &DecodingKey::from_secret(key),
        &validation,
    )?;

    Ok(token_data)
}

/// Build a swagger-Authorization based on the claims (Assuming claims have been extracted from a validated token)
fn build_authorization(claims: Claims) -> Authorization {
    let mut scopes = std::collections::BTreeSet::<String>::new();
    claims
        .scopes
        .split(",")
        .map(|s| s.trim())
        .for_each(|s| {let _ = scopes.insert(s.to_string()); });
    let scopes = swagger::auth::Scopes::Some(scopes);

    Authorization{
        subject: claims.sub,
        scopes,
        issuer: Some(claims.iss)}
}

fn get_jwt_error_string(error: JwtError::Error) -> String {
    match error.kind() {
        JwtError::ErrorKind::InvalidSignature => "Incorrect token signature".to_owned(),
        JwtError::ErrorKind::InvalidAlgorithm => "The Algorithm is not correct".to_owned(),
        JwtError::ErrorKind::ExpiredSignature => "The token has expired".to_owned(),
        JwtError::ErrorKind::Base64(e) => format!("Base64 decode failed: {e}"),
        JwtError::ErrorKind::Json(e) => format!("JSON decoding: {e}"),
        JwtError::ErrorKind::Utf8(e) => format!("Invalid UTF-8: {e}"),
        _ => error.to_string()
    }
}


impl<C> AuthenticationApi for Server<C> where C: Has<XSpanIdString> + Send + Sync {

    /// Implementation of the method to map a Bearer-token to an Authorization
    fn bearer_authorization(&self, bearer: &Bearer) -> Result<Authorization, ApiError> {
        debug!("\tAuthorizationApi: Received Bearer-token, {bearer:#?}");

        match extract_token_data(&bearer.token, b"secret") {
            Ok(auth_data) => {
                debug!("\tUnpack auth_data as: {auth_data:#?}");
                let authorization = build_authorization(auth_data.claims);
                Ok(authorization)
            },
            Err(err) => {
                let msg = get_jwt_error_string(err);
                error!("Failed to unpack Bearer-token: {msg}");
                Err(ApiError(msg))
            }
        }
    }

    /// Implementation of the method to map an api-key to an Authorization
    fn apikey_authorization(&self, api_key: &str) -> Result<Authorization, ApiError> {
        debug!("\tAuthorizationApi: Received api-key, {api_key:#?}");

        // TODO: insert the logic to map received apikey to the set of claims
        let claims = full_permission_claim();

        // and build an authorization out of it
        Ok(build_authorization(claims))
    }

    /// Implementation of the method to map a basic authentication (username and password) to an Authorization
    fn basic_authorization(&self, basic: &Basic) -> Result<Authorization, ApiError> {
        debug!("\tAuthorizationApi: Received Basic-token, {basic:#?}");

        // TODO: insert the logic to map received apikey to the set of claims
        let claims = full_permission_claim();

        // and build an authorization out of it
        Ok(build_authorization(claims))
    }

}

example-server-chain.pem:
Certificate:
    Data:
        Version: 1 (0x0)
        Serial Number: 4096 (0x1000)
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: C=US, CN=My CA
        Validity
            Not Before: May 23 16:00:23 2017 GMT
            Not After : Apr 29 16:00:23 2117 GMT
        Subject: CN=localhost, C=US
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:c9:d4:43:60:50:fc:d6:0f:38:4d:5d:5e:aa:7c:
                    c0:5e:a9:ec:d9:93:78:d3:93:72:28:41:f5:08:a5:
                    ea:ac:67:07:d7:1f:f7:7d:74:69:7e:46:89:20:4b:
                    7a:2d:9b:02:08:e7:6f:0f:1d:0c:0f:c7:60:69:19:
                    4b:df:7e:ca:75:94:0b:49:71:e3:6d:f2:e8:79:fd:
                    ed:0a:94:67:55:f3:ca:6b:61:ba:58:b7:2e:dd:7b:
                    ca:b9:02:9f:24:36:ac:26:8f:04:8f:81:c8:35:10:
                    f4:aa:33:b2:24:16:f8:f7:1e:ea:f7:16:fe:fa:34:
                    c3:dd:bb:2c:ba:7a:df:4d:e2:da:1e:e5:d2:28:44:
                    6e:c8:96:e0:fd:09:0c:14:0c:31:dc:e0:ca:c1:a7:
                    9b:bf:16:8c:f7:36:3f:1b:2e:dd:90:eb:45:78:51:
                    bf:59:22:1e:c6:8c:0a:69:88:e5:03:5e:73:b7:fc:
                    93:7f:1b:46:1b:97:68:c5:c0:8b:35:1f:bb:1e:67:
                    7f:55:b7:3b:55:3f:ea:f2:ca:db:cc:52:cd:16:89:
                    db:15:47:bd:f2:cd:6c:7a:d7:b4:1a:ac:c8:15:6c:
                    6a:fb:77:c4:e9:f2:30:e0:14:24:66:65:6f:2a:e5:
                    2d:cc:f6:81:ae:57:c8:d1:9b:38:90:dc:60:93:02:
                    5e:cb
                Exponent: 65537 (0x10001)
    Signature Algorithm: sha256WithRSAEncryption
         1c:7c:39:e8:3d:49:b2:09:1e:68:5a:2f:74:18:f4:63:b5:8c:
         f6:e6:a1:e3:4d:95:90:99:ef:32:5c:34:40:e8:55:13:0e:e0:
         1c:be:cd:ab:3f:64:38:99:5e:2b:c1:81:53:a0:18:a8:f6:ee:
         6a:33:73:6c:9a:73:9d:86:08:5d:c7:11:38:46:4c:cd:a0:47:
         37:8f:fe:a6:50:a9:02:21:99:42:86:5e:47:fe:65:56:60:1d:
         16:53:86:bd:e4:63:c5:69:cf:fa:30:51:ab:a1:c3:50:53:cc:
         66:1c:4c:ff:3f:2a:39:4d:a2:8f:9d:d1:a7:8b:22:e4:78:69:
         24:06:83:4d:cc:0a:c0:87:69:9b:bc:80:a9:d2:b7:a5:23:84:
         7e:a2:32:26:7c:78:0e:bd:db:cd:3b:69:18:33:b8:44:ef:96:
         b4:99:86:ee:06:bd:51:1c:c7:a1:a4:0c:c4:4c:51:a0:df:ac:
         14:07:88:8e:d7:39:45:fe:52:e0:a3:4c:db:5d:7a:ab:4d:e4:
         ca:06:e8:bd:74:6f:46:e7:93:4a:4f:1b:67:e7:a5:9f:ef:9c:
         02:49:d1:f2:d5:e9:53:ee:09:21:ac:08:c8:15:f7:af:35:b9:
         4f:11:0f:43:ae:46:8e:fd:5b:8d:a3:4e:a7:2c:b7:25:ed:e4:
         e5:94:1d:e3
-----BEGIN CERTIFICATE-----
MIICtTCCAZ0CAhAAMA0GCSqGSIb3DQEBCwUAMB0xCzAJBgNVBAYTAlVTMQ4wDAYD
VQQDEwVNeSBDQTAgFw0xNzA1MjMxNjAwMjNaGA8yMTE3MDQyOTE2MDAyM1owITES
MBAGA1UEAxMJbG9jYWxob3N0MQswCQYDVQQGEwJVUzCCASIwDQYJKoZIhvcNAQEB
BQADggEPADCCAQoCggEBAMnUQ2BQ/NYPOE1dXqp8wF6p7NmTeNOTcihB9Qil6qxn
B9cf9310aX5GiSBLei2bAgjnbw8dDA/HYGkZS99+ynWUC0lx423y6Hn97QqUZ1Xz
ymthuli3Lt17yrkCnyQ2rCaPBI+ByDUQ9KozsiQW+Pce6vcW/vo0w927LLp6303i
2h7l0ihEbsiW4P0JDBQMMdzgysGnm78WjPc2Pxsu3ZDrRXhRv1kiHsaMCmmI5QNe
c7f8k38bRhuXaMXAizUfux5nf1W3O1U/6vLK28xSzRaJ2xVHvfLNbHrXtBqsyBVs
avt3xOnyMOAUJGZlbyrlLcz2ga5XyNGbOJDcYJMCXssCAwEAATANBgkqhkiG9w0B
AQsFAAOCAQEAHHw56D1JsgkeaFovdBj0Y7WM9uah402VkJnvMlw0QOhVEw7gHL7N
qz9kOJleK8GBU6AYqPbuajNzbJpznYYIXccROEZMzaBHN4/+plCpAiGZQoZeR/5l
VmAdFlOGveRjxWnP+jBRq6HDUFPMZhxM/z8qOU2ij53Rp4si5HhpJAaDTcwKwIdp
m7yAqdK3pSOEfqIyJnx4Dr3bzTtpGDO4RO+WtJmG7ga9URzHoaQMxExRoN+sFAeI
jtc5Rf5S4KNM2116q03kygbovXRvRueTSk8bZ+eln++cAknR8tXpU+4JIawIyBX3
rzW5TxEPQ65Gjv1bjaNOpyy3Je3k5ZQd4w==
-----END CERTIFICATE-----
example-server-common.mustache:
//! Main library entry point for {{{externCrateName}}} implementation.

#![allow(unused_imports)]

use async_trait::async_trait;
use futures::{future, Stream, StreamExt, TryFutureExt, TryStreamExt};
use hyper::server::conn::Http;
use hyper::service::Service;
use log::info;
use std::future::Future;
use std::marker::PhantomData;
use std::net::SocketAddr;
use std::sync::{Arc, Mutex};
use std::task::{Context, Poll};
use swagger::{Has, XSpanIdString};
use swagger::auth::MakeAllowAllAuthenticator;
use swagger::EmptyContext;
use tokio::net::TcpListener;

#[cfg(not(any(target_os = "macos", target_os = "windows", target_os = "ios")))]
use openssl::ssl::{Ssl, SslAcceptor, SslAcceptorBuilder, SslFiletype, SslMethod};

use {{{externCrateName}}}::models;

/// Builds an SSL implementation for Simple HTTPS from some hard-coded file names
pub async fn create(addr: &str, https: bool) {
    let addr = addr.parse().expect("Failed to parse bind address");

    let server = Server::new();

    let service = MakeService::new(server);

    let service = MakeAllowAllAuthenticator::new(service, "cosmo");

    #[allow(unused_mut)]
    let mut service =
        {{{externCrateName}}}::server::context::MakeAddContext::<_, EmptyContext>::new(
            service
        );

    if https {
        #[cfg(any(target_os = "macos", target_os = "windows", target_os = "ios"))]
        {
            unimplemented!("SSL is not implemented for the examples on MacOS, Windows or iOS");
        }

        #[cfg(not(any(target_os = "macos", target_os = "windows", target_os = "ios")))]
        {
            let mut ssl = SslAcceptor::mozilla_intermediate_v5(SslMethod::tls()).expect("Failed to create SSL Acceptor");

            // Server authentication
            ssl.set_private_key_file("examples/server-key.pem", SslFiletype::PEM).expect("Failed to set private key");
            ssl.set_certificate_chain_file("examples/server-chain.pem").expect("Failed to set certificate chain");
            ssl.check_private_key().expect("Failed to check private key");

            let tls_acceptor = ssl.build();
            let tcp_listener = TcpListener::bind(&addr).await.unwrap();

            info!("Starting a server (with https)");
            loop {
                if let Ok((tcp, _)) = tcp_listener.accept().await {
                    let ssl = Ssl::new(tls_acceptor.context()).unwrap();
                    let addr = tcp.peer_addr().expect("Unable to get remote address");
                    let service = service.call(addr);

                    tokio::spawn(async move {
                        let tls = tokio_openssl::SslStream::new(ssl, tcp).map_err(|_| ())?;
                        let service = service.await.map_err(|_| ())?;

                        Http::new()
                            .serve_connection(tls, service)
                            .await
                            .map_err(|_| ())
                    });
                }
            }
        }
    } else {
        info!("Starting a server (over http, so no TLS)");
        // Using HTTP
        hyper::server::Server::bind(&addr).serve(service).await.unwrap()
    }
}

#[derive(Copy, Clone)]
pub struct Server<C> {
    marker: PhantomData<C>,
}

impl<C> Server<C> {
    pub fn new() -> Self {
        Server{marker: PhantomData}
    }
}
example-server-key.pem:
-----BEGIN PRIVATE KEY-----
MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDJ1ENgUPzWDzhN
XV6qfMBeqezZk3jTk3IoQfUIpeqsZwfXH/d9dGl+RokgS3otmwII528PHQwPx2Bp
GUvffsp1lAtJceNt8uh5/e0KlGdV88prYbpYty7de8q5Ap8kNqwmjwSPgcg1EPSq
M7IkFvj3Hur3Fv76NMPduyy6et9N4toe5dIoRG7IluD9CQwUDDHc4MrBp5u/Foz3
Nj8bLt2Q60V4Ub9ZIh7GjAppiOUDXnO3/JN/G0Ybl2jFwIs1H7seZ39VtztVP+ry
ytvMUs0WidsVR73yzWx617QarMgVbGr7d8Tp8jDgFCRmZW8q5S3M9oGuV8jRmziQ
3GCTAl7LAgMBAAECggEBAKEd1q9j14KWYc64s6KLthGbutyxsinMMbxbct11fdIk
6YhdF3fJ35ETg9IJDr6rWEN9ZRX+jStncNpVfFEs6ThVd3Eo/nI+EEGaaIkikR93
X2a7fEPn7/yVHu70XdBN6L1bPDvHUeiy4W2hmRrgT90OjGm1rNRWHOm7yugOwIZu
HclzbR9Ca7EInFnotUiDQm9sw9VKHbJHqWx6OORdZrxR2ytYs0Qkq0XpGMvti2HW
7WAmKTg5QM8myXW7+/4iqb/u68wVBR2BBalShKmIf7lim9O3W2a1RjDdsvm/wNe9
I+D+Iq825vpqkKXcrxYlpVg7hYiaQaW/MNsEb7lQRjECgYEA/RJYby0POW+/k0Jn
jO8UmJVEMiuGa8WIUu/JJWMOmzRCukjSRNQOkt7niQrZPJYE8W6clM6RJTolWf9L
IL6mIb+mRaoudUk8SHGDq7ho1iMg9GK8lhYxvKh1Q6uv8EyVSkgLknAEY0NANKC1
zNdU5Dhven9aRX2gq9vP4XwMz2MCgYEAzCogQ7IFk+gkp3k491dOZnrGRoRCfuzo
4CJtyKFgOSd7BjmpcKkj0IPfVBjw6GjMIxfQRMTQmxAjjWevH45vG8l0Iiwz/gSp
81b5nsDEX5uv2Olcmcz5zxRFy36jOZ9ihMWinxcIlT2oDbyCdbruDKZq9ieJ9S8g
4qGx0OkwE3kCgYEA7CmAiU89U9YqqttfEq/RQoqY91CSwmO10d+ej9seuEtOsdRf
FIfnibulycdr7hP5TOxyBpO1802NqayJiWcgVYIpQf2MGTtcnCYCP+95NcvWZvj1
EAJqK6nwtFO1fcOZ1ZXh5qfOEGujsPkAbsXLnKXlsiTCMvMHSxl3pu5Cbg0CgYBf
JjbZNctRrjv+7Qj2hPLd4dQsIxGWc7ToWENP4J2mpVa5hQAJqFovoHXhjKohtk2F
AWEn243Y5oGbMjo0e74edhmwn2cvuF64MM2vBem/ISCn98IXT6cQskMA3qkVfsl8
VVs/x41ReGWs2TD3y0GMFbb9t1mdMfSiincDhNnKCQKBgGfeT4jKyYeCoCw4OLI1
G75Gd0METt/IkppwODPpNwj3Rp9I5jctWZFA/3wCX/zk0HgBeou5AFNS4nQZ/X/L
L9axbSdR7UJTGkT1r4gu3rLkPV4Tk+8XM03/JT2cofMlzQBuhvl1Pn4SgKowz7hl
lS76ECw4Av3T0S34VW9Z5oye
-----END PRIVATE KEY-----
example-server-main.mustache:
//! Main binary entry point for {{{externCrateName}}} implementation.
// This is the amended version that adds Authorization via Inversion of Control.

#![allow(missing_docs)]


use clap::{App, Arg};

mod server;
mod server_auth;


/// Create custom server, wire it to the autogenerated router,
/// and pass it to the web server.
#[tokio::main]
async fn main() {
    env_logger::init();

    let matches = App::new("server")
        .arg(Arg::with_name("https")
            .long("https")
            .help("Whether to use HTTPS or not"))
        .get_matches();

    let addr = "127.0.0.1:{{{serverPort}}}";

    server::create(addr, matches.is_present("https")).await;
}
example-server-operation.mustache:
{{#summary}}
    /// {{{.}}}
{{/summary}}
    async fn {{#vendorExtensions}}{{{x-operation-id}}}{{/vendorExtensions}}(
        &self,
{{#vendorExtensions}}
  {{#x-callback-params}}
        callback_{{.}}: String,
  {{/x-callback-params}}
{{/vendorExtensions}}
{{#allParams}}
        {{{paramName}}}: {{^required}}Option<{{/required}}{{#isArray}}&{{/isArray}}{{{dataType}}}{{^required}}>{{/required}},
{{/allParams}}
        context: &C) -> Result<{{{operationId}}}Response, ApiError>
    {
        info!("{{#vendorExtensions}}{{{x-operation-id}}}{{/vendorExtensions}}({{#allParams}}{{#vendorExtensions}}{{{x-format-string}}}{{/vendorExtensions}}{{^-last}}, {{/-last}}{{/allParams}}) - X-Span-ID: {:?}"{{#allParams}}, {{{paramName}}}{{/allParams}}, context.get().0.clone());
        Err(ApiError("Api-Error: Operation is NOT implemented".into()))
    }
example-server-server.mustache:
{{>example-server-common}}

use jsonwebtoken::{decode, encode, errors::Error as JwtError, Algorithm, DecodingKey, EncodingKey, Header, TokenData, Validation};
use serde::{Deserialize, Serialize};
use swagger::auth::Authorization;
use crate::server_auth;


use {{{externCrateName}}}::{
    Api,
{{#apiInfo}}
  {{#apis}}
    {{#operations}}
      {{#operation}}
    {{{operationId}}}Response,
      {{/operation}}
    {{/operations}}
  {{/apis}}
{{/apiInfo}}
};
use {{{externCrateName}}}::server::MakeService;
use std::error::Error;
use swagger::ApiError;

#[async_trait]
impl<C> Api<C> for Server<C> where C: Has<XSpanIdString> + Send + Sync
{
{{#apiInfo}}
  {{#apis}}
    {{#operations}}
      {{#operation}}
{{>example-server-operation}}
      {{/operation}}
    {{/operations}}
  {{/apis}}
{{/apiInfo}}
}
generate-multipart-related.mustache:
{{#-first}}
        let boundary = swagger::multipart::related::generate_boundary();
        let mut body_parts = vec![];

{{/-first}}
{{#required}}
        {
{{/required}}
{{^required}}
        if let Some({{{paramName}}}) = param_{{{paramName}}} {
{{/required}}
            let part = Node::Part(Part {
                headers: {
                    let mut h = Headers::new();
                    h.set(ContentType("{{{contentType}}}".parse().unwrap()));
                    h.set_raw("Content-ID", vec![b"{{{baseName}}}".to_vec()]);
                    h
                },
                {{#isBinary}}
                body: {{#required}}param_{{/required}}{{{paramName}}}.0,
                {{/isBinary}}
                {{^isBinary}}
                body: serde_json::to_string(&{{{paramName}}})
                    .expect("Impossible to fail to serialize")
                    .into_bytes(),
                {{/isBinary}}
            });
            body_parts.push(part);
        }
{{#-last}}

        // Write the body into a vec.
        // RFC 13341 Section 7.2.1 suggests that the body should begin with a
        // CRLF prior to the first boundary. The mime_multipart library doesn't
        // do this, so we do it instead.
        let mut body: Vec<u8> = vec![b'\r', b'\n'];
        write_multipart(&mut body, &boundary, &body_parts)
            .expect("Failed to write multipart body");
{{/-last}}
gitignore:
target
Cargo.lock
header.mustache:
use chrono::{DateTime, Utc};
use hyper::header::HeaderValue;
use std::convert::TryFrom;
use std::fmt;
use std::ops::Deref;

/// A struct to allow homogeneous conversion into a HeaderValue. We can't
/// implement the From/Into trait on HeaderValue because we don't own
/// either of the types.
#[derive(Debug, Clone)]
pub(crate) struct IntoHeaderValue<T>(pub T);

// Generic implementations

impl<T> Deref for IntoHeaderValue<T> {
    type Target = T;

    fn deref(&self) -> &T {
        &self.0
    }
}

// Derive for each TryFrom<T> in hyper::header::HeaderValue

macro_rules! ihv_generate {
    ($t:ident) => {
        impl TryFrom<HeaderValue> for IntoHeaderValue<$t> {
            type Error = String;

            fn try_from(hdr_value: HeaderValue) -> Result<Self, Self::Error> {
                match hdr_value.to_str() {
                    Ok(hdr_value) => match hdr_value.parse::<$t>() {
                        Ok(hdr_value) => Ok(IntoHeaderValue(hdr_value)),
                        Err(e) => Err(format!("Unable to parse {} as a string: {}",
                            stringify!($t), e)),
                    },
                    Err(e) => Err(format!("Unable to parse header {:?} as a string - {}",
                        hdr_value, e)),
                }
            }
        }

        impl TryFrom<IntoHeaderValue<$t>> for HeaderValue {
            type Error = String;

            fn try_from(hdr_value: IntoHeaderValue<$t>) -> Result<Self, Self::Error> {
                Ok(hdr_value.0.into())
            }
        }
    };
}

ihv_generate!(u64);
ihv_generate!(i64);
ihv_generate!(i16);
ihv_generate!(u16);
ihv_generate!(u32);
ihv_generate!(usize);
ihv_generate!(isize);
ihv_generate!(i32);

// Custom derivations

// Vec<String>

impl TryFrom<HeaderValue> for IntoHeaderValue<Vec<String>> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> Result<Self, Self::Error> {
        match hdr_value.to_str() {
            Ok(hdr_value) => Ok(IntoHeaderValue(
                hdr_value
                .split(',')
                .filter_map(|x| match x.trim() {
                    "" => None,
                    y => Some(y.to_string()),
                })
                .collect())),
            Err(e) => Err(format!("Unable to parse header: {:?} as a string - {}",
                hdr_value, e)),
        }
    }
}

impl TryFrom<IntoHeaderValue<Vec<String>>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: IntoHeaderValue<Vec<String>>) -> Result<Self, Self::Error> {
       match HeaderValue::from_str(&hdr_value.0.join(", ")) {
           Ok(hdr_value) => Ok(hdr_value),
           Err(e) => Err(format!("Unable to convert {:?} into a header - {}",
               hdr_value, e))
       }
    }
}

// String

impl TryFrom<HeaderValue> for IntoHeaderValue<String> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> Result<Self, Self::Error> {
        match hdr_value.to_str() {
            Ok(hdr_value) => Ok(IntoHeaderValue(hdr_value.to_string())),
            Err(e) => Err(format!("Unable to convert header {:?} to {}",
                hdr_value, e)),
        }
    }
}

impl TryFrom<IntoHeaderValue<String>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: IntoHeaderValue<String>) -> Result<Self, Self::Error> {
        match HeaderValue::from_str(&hdr_value.0) {
            Ok(hdr_value) => Ok(hdr_value),
            Err(e) => Err(format!("Unable to convert {:?} from a header {}",
                hdr_value, e))
        }
    }
}

// bool
impl TryFrom<HeaderValue> for IntoHeaderValue<bool> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> Result<Self, Self::Error> {
        match hdr_value.to_str() {
            Ok(hdr_value) => match hdr_value.parse() {
                Ok(hdr_value) => Ok(IntoHeaderValue(hdr_value)),
                Err(e) => Err(format!("Unable to parse bool from {} - {}",
                    hdr_value, e)),
            },
            Err(e) => Err(format!("Unable to convert {:?} from a header {}",
                hdr_value, e)),
        }
    }
}

impl TryFrom<IntoHeaderValue<bool>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: IntoHeaderValue<bool>) -> Result<Self, Self::Error> {
        match HeaderValue::from_str(&hdr_value.0.to_string()) {
            Ok(hdr_value) => Ok(hdr_value),
            Err(e) => Err(format!("Unable to convert: {:?} into a header: {}",
                hdr_value, e))
        }
    }
}

// DateTime

impl TryFrom<HeaderValue> for IntoHeaderValue<DateTime<Utc>> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> Result<Self, Self::Error> {
        match hdr_value.to_str() {
            Ok(hdr_value) => match DateTime::parse_from_rfc3339(hdr_value) {
                Ok(date) => Ok(IntoHeaderValue(date.with_timezone(&Utc))),
                Err(e) => Err(format!("Unable to parse: {} as date - {}",
                    hdr_value, e)),
            },
            Err(e) => Err(format!("Unable to convert header {:?} to string {}",
                    hdr_value, e)),
        }
    }
}

impl TryFrom<IntoHeaderValue<DateTime<Utc>>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: IntoHeaderValue<DateTime<Utc>>) -> Result<Self, Self::Error> {
        match HeaderValue::from_str(hdr_value.0.to_rfc3339().as_str()) {
            Ok(hdr_value) => Ok(hdr_value),
            Err(e) => Err(format!("Unable to convert {:?} to a header: {}",
                hdr_value, e)),
        }
    }
}
lib.mustache:
#![allow(missing_docs, trivial_casts, unused_variables, unused_mut, unused_imports, unused_extern_crates, unused_attributes, non_camel_case_types)]
#![allow(clippy::derive_partial_eq_without_eq, clippy::disallowed_names)]

use async_trait::async_trait;
use futures::Stream;
use std::error::Error;
use std::collections::BTreeSet;
use std::task::{Poll, Context};
// use swagger::{ApiError, ContextWrapper};
use serde::{Serialize, Deserialize};
// use crate::server::Authorization;


type ServiceError = Box<dyn Error + Send + Sync + 'static>;

pub const BASE_PATH: &str = "{{{basePathWithoutHost}}}";
{{#appVersion}}
pub const API_VERSION: &str = "{{{.}}}";
{{/appVersion}}

mod auth;
pub use auth::{AuthenticationApi, Claims};


{{#apiInfo}}
  {{#apis}}
    {{#operations}}
      {{#operation}}
{{>response}}
      {{/operation}}
    {{/operations}}
  {{/apis}}
{{/apiInfo}}
/// API
#[async_trait]
#[allow(clippy::too_many_arguments, clippy::ptr_arg)]
pub trait Api<C: Send + Sync> {
    fn poll_ready(&self, _cx: &mut Context) -> Poll<Result<(), Box<dyn Error + Send + Sync + 'static>>> {
        Poll::Ready(Ok(()))
    }

{{#apiInfo}}
  {{#apis}}
    {{#operations}}
      {{#operation}}
{{#summary}}
    /// {{{.}}}
{{/summary}}
    async fn {{#vendorExtensions}}{{{x-operation-id}}}{{/vendorExtensions}}(
        &self,
{{#allParams}}
        {{{paramName}}}: {{^required}}Option<{{/required}}{{#isArray}}&{{/isArray}}{{{dataType}}}{{^required}}>{{/required}},
{{/allParams}}
        context: &C) -> Result<{{{operationId}}}Response, ApiError>;

      {{/operation}}
    {{/operations}}
  {{/apis}}
{{/apiInfo}}
}

/// API where `Context` isn't passed on every API call
#[async_trait]
#[allow(clippy::too_many_arguments, clippy::ptr_arg)]
pub trait ApiNoContext<C: Send + Sync> {

    fn poll_ready(&self, _cx: &mut Context) -> Poll<Result<(), Box<dyn Error + Send + Sync + 'static>>>;

    fn context(&self) -> &C;

{{#apiInfo}}
  {{#apis}}
    {{#operations}}
      {{#operation}}
{{#summary}}
    /// {{{.}}}
{{/summary}}
    async fn {{#vendorExtensions}}{{{x-operation-id}}}{{/vendorExtensions}}(
        &self,
{{#allParams}}
        {{{paramName}}}: {{^required}}Option<{{/required}}{{#isArray}}&{{/isArray}}{{{dataType}}}{{^required}}>{{/required}},
{{/allParams}}
        ) -> Result<{{{operationId}}}Response, ApiError>;

      {{/operation}}
    {{/operations}}
  {{/apis}}
{{/apiInfo}}
}

/// Trait to extend an API to make it easy to bind it to a context.
pub trait ContextWrapperExt<C: Send + Sync> where Self: Sized
{
    /// Binds this API to a context.
    fn with_context(self, context: C) -> ContextWrapper<Self, C>;
}

impl<T: Api<C> + Send + Sync, C: Clone + Send + Sync> ContextWrapperExt<C> for T {
    fn with_context(self: T, context: C) -> ContextWrapper<T, C> {
         ContextWrapper::<T, C>::new(self, context)
    }
}

#[async_trait]
impl<T: Api<C> + Send + Sync, C: Clone + Send + Sync> ApiNoContext<C> for ContextWrapper<T, C> {
    fn poll_ready(&self, cx: &mut Context) -> Poll<Result<(), ServiceError>> {
        self.api().poll_ready(cx)
    }

    fn context(&self) -> &C {
        ContextWrapper::context(self)
    }

{{#apiInfo}}
  {{#apis}}
    {{#operations}}
      {{#operation}}
{{#summary}}
    /// {{{.}}}
{{/summary}}
    async fn {{#vendorExtensions}}{{{x-operation-id}}}{{/vendorExtensions}}(
        &self,
{{#allParams}}
        {{{paramName}}}: {{^required}}Option<{{/required}}{{#isArray}}&{{/isArray}}{{{dataType}}}{{^required}}>{{/required}},
{{/allParams}}
        ) -> Result<{{{operationId}}}Response, ApiError>
    {
        let context = self.context().clone();
        self.api().{{#vendorExtensions}}{{{x-operation-id}}}{{/vendorExtensions}}({{#allParams}}{{{paramName}}}, {{/allParams}}&context).await
    }

      {{/operation}}
    {{/operations}}
  {{/apis}}
{{/apiInfo}}
}

{{#hasCallbacks}}

{{#apiInfo}}
    {{#apis}}
      {{#operations}}
        {{#operation}}
          {{#callbacks}}
            {{#urls}}
              {{#requests}}
{{>response}}
            {{/requests}}
          {{/urls}}
        {{/callbacks}}
      {{/operation}}
    {{/operations}}
  {{/apis}}
{{/apiInfo}}

/// Callback API
#[async_trait]
pub trait CallbackApi<C: Send + Sync> {
    fn poll_ready(&self, _cx: &mut Context) -> Poll<Result<(), Box<dyn Error + Send + Sync + 'static>>> {
        Poll::Ready(Ok(()))
    }

{{#apiInfo}}
  {{#apis}}
    {{#operations}}
      {{#operation}}
        {{#callbacks}}
          {{#urls}}
            {{#requests}}
{{#summary}}
    /// {{{.}}}
{{/summary}}
    async fn {{#vendorExtensions}}{{{x-operation-id}}}{{/vendorExtensions}}(
        &self,
{{#vendorExtensions}}
  {{#x-callback-params}}
        callback_{{.}}: String,
  {{/x-callback-params}}
{{/vendorExtensions}}
{{#allParams}}
        {{{paramName}}}: {{^required}}Option<{{/required}}{{#isArray}}&{{/isArray}}{{{dataType}}}{{^required}}>{{/required}},
{{/allParams}}
        context: &C) -> Result<{{{operationId}}}Response, ApiError>;

            {{/requests}}
          {{/urls}}
        {{/callbacks}}
      {{/operation}}
    {{/operations}}
  {{/apis}}
{{/apiInfo}}
}

/// Callback API without a `Context`
#[async_trait]
pub trait CallbackApiNoContext<C: Send + Sync> {
    fn poll_ready(&self, _cx: &mut Context) -> Poll<Result<(), Box<dyn Error + Send + Sync + 'static>>>;

    fn context(&self) -> &C;

{{#apiInfo}}
  {{#apis}}
    {{#operations}}
      {{#operation}}
        {{#callbacks}}
          {{#urls}}
            {{#requests}}
{{#summary}}
    /// {{{.}}}
{{/summary}}
    async fn {{#vendorExtensions}}{{{x-operation-id}}}{{/vendorExtensions}}(
        &self,
{{#vendorExtensions}}
  {{#x-callback-params}}
        callback_{{.}}: String,
  {{/x-callback-params}}
{{/vendorExtensions}}
{{#allParams}}
        {{{paramName}}}: {{^required}}Option<{{/required}}{{#isArray}}&{{/isArray}}{{{dataType}}}{{^required}}>{{/required}},
{{/allParams}}
        ) -> Result<{{{operationId}}}Response, ApiError>;

            {{/requests}}
          {{/urls}}
        {{/callbacks}}
      {{/operation}}
    {{/operations}}
  {{/apis}}
{{/apiInfo}}
}

pub trait CallbackContextWrapperExt<C: Send + Sync> where Self: Sized
{
    /// Binds this API to a context.
    fn with_context(self, context: C) -> ContextWrapper<Self, C>;
}

impl<T: CallbackApi<C> + Send + Sync, C: Clone + Send + Sync> CallbackContextWrapperExt<C> for T {
    fn with_context(self: T, context: C) -> ContextWrapper<T, C> {
         ContextWrapper::<T, C>::new(self, context)
    }
}

#[async_trait]
impl<T: CallbackApi<C> + Send + Sync, C: Clone + Send + Sync> CallbackApiNoContext<C> for ContextWrapper<T, C> {
    fn poll_ready(&self, cx: &mut Context) -> Poll<Result<(), ServiceError>> {
        self.api().poll_ready(cx)
    }

    fn context(&self) -> &C {
        ContextWrapper::context(self)
    }

{{#apiInfo}}
  {{#apis}}
    {{#operations}}
      {{#operation}}
        {{#callbacks}}
          {{#urls}}
            {{#requests}}
              {{#summary}}
    /// {{{.}}}
              {{/summary}}
    async fn {{#vendorExtensions}}{{{x-operation-id}}}{{/vendorExtensions}}(
        &self,
{{#vendorExtensions}}
  {{#x-callback-params}}
        callback_{{.}}: String,
  {{/x-callback-params}}
{{/vendorExtensions}}
{{#allParams}}
        {{{paramName}}}: {{^required}}Option<{{/required}}{{#isArray}}&{{/isArray}}{{{dataType}}}{{^required}}>{{/required}},
{{/allParams}}
        ) -> Result<{{{operationId}}}Response, ApiError>
    {
        let context = self.context().clone();
        self.api().{{#vendorExtensions}}{{{x-operation-id}}}{{/vendorExtensions}}(
{{#vendorExtensions}}
  {{#x-callback-params}}
            callback_{{.}},
  {{/x-callback-params}}
{{/vendorExtensions}}
{{#allParams}}
            {{{paramName}}},
{{/allParams}}
            &context).await
    }

            {{/requests}}
          {{/urls}}
        {{/callbacks}}
      {{/operation}}
    {{/operations}}
  {{/apis}}
{{/apiInfo}}
}

{{/hasCallbacks}}

#[cfg(feature = "client")]
pub mod client;

// Re-export Client as a top-level name
#[cfg(feature = "client")]
pub use client::Client;

#[cfg(feature = "server")]
pub mod server;

// Re-export router() as a top-level name
#[cfg(feature = "server")]
pub use self::server::Service;

{{#hasCallbacks}}
#[cfg(any(feature = "client", feature = "server"))]
{{/hasCallbacks}}
{{^hasCallbacks}}
#[cfg(feature = "server")]
{{/hasCallbacks}}
pub mod context;

pub mod models;

#[cfg(any(feature = "client", feature = "server"))]
pub(crate) mod header;
model_doc.mustache:
{{#models}}{{#model}}# {{{classname}}}

## Properties
Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
{{#vars}}**{{{name}}}** | {{#isPrimitiveType}}**{{{dataType}}}**{{/isPrimitiveType}}{{^isPrimitiveType}}[**{{^isContainer}}{{^isDateTime}}*{{/isDateTime}}{{/isContainer}}{{{dataType}}}**]({{{complexType}}}.md){{/isPrimitiveType}} | {{{description}}} | {{^required}}[optional] {{/required}}{{#isReadOnly}}[readonly] {{/isReadOnly}}{{#defaultValue}}[default to {{{.}}}]{{/defaultValue}}
{{/vars}}

[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)

{{/model}}{{/models}}
models.mustache:
#![allow(unused_qualifications)]

use validator::Validate;

use crate::models;
#[cfg(any(feature = "client", feature = "server"))]
use crate::header;
{{! Don't "use" structs here - they can conflict with the names of models, and mean that the code won't compile }}
{{#models}}
{{#model}}

{{#description}}
/// {{{.}}}
{{/description}}
{{#isEnum}}
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize, Hash)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]{{#xmlName}}
#[serde(rename = "{{{.}}}")]{{/xmlName}}
pub enum {{{classname}}} {
{{#allowableValues}}
  {{#enumVars}}
    #[serde(rename = {{{value}}})]
    {{{name}}},
  {{/enumVars}}
{{/allowableValues}}
}

impl std::fmt::Display for {{{classname}}} {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
{{#allowableValues}}
  {{#enumVars}}
            {{{classname}}}::{{{name}}} => write!(f, {{{value}}}),
  {{/enumVars}}
{{/allowableValues}}
        }
    }
}

impl std::str::FromStr for {{{classname}}} {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
{{#allowableValues}}
  {{#enumVars}}
            {{{value}}} => std::result::Result::Ok({{{classname}}}::{{{name}}}),
  {{/enumVars}}
{{/allowableValues}}
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}
{{/isEnum}}
{{^isEnum}}
{{#dataType}}
#[derive(Debug, Clone, PartialEq, {{#vendorExtensions.x-partial-ord}}PartialOrd, {{/vendorExtensions.x-partial-ord}}serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
{{#xmlName}}
#[serde(rename = "{{{.}}}")]
{{/xmlName}}
pub struct {{{classname}}}({{{dataType}}});

impl std::convert::From<{{{dataType}}}> for {{{classname}}} {
    fn from(x: {{{dataType}}}) -> Self {
        {{{classname}}}(x)
    }
}

impl std::convert::From<{{{classname}}}> for {{{dataType}}} {
    fn from(x: {{{classname}}}) -> Self {
        x.0
    }
}

impl std::ops::Deref for {{{classname}}} {
    type Target = {{{dataType}}};
    fn deref(&self) -> &{{{dataType}}} {
        &self.0
    }
}

impl std::ops::DerefMut for {{{classname}}} {
    fn deref_mut(&mut self) -> &mut {{{dataType}}} {
        &mut self.0
    }
}

{{#vendorExtensions.x-to-string-support}}
{{#vendorExtensions.x-is-string}}
impl std::string::ToString for {{{classname}}} {
    fn to_string(&self) -> String {
       self.0.clone()
    }
}

impl std::str::FromStr for {{{classname}}} {
    type Err = ::std::convert::Infallible;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok({{{classname}}}(x.to_owned()))
    }
}
{{/vendorExtensions.x-is-string}}
{{^vendorExtensions.x-is-string}}
/// Converts the {{{classname}}} value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl ::std::string::ToString for {{{classname}}} {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a {{{classname}}} value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl ::std::str::FromStr for {{{classname}}} {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match std::str::FromStr::from_str(s) {
             std::result::Result::Ok(r) => std::result::Result::Ok({{{classname}}}(r)),
             std::result::Result::Err(e) => std::result::Result::Err(format!("Unable to convert {} to {{{classname}}}: {:?}", s, e)),
        }
    }
}
{{/vendorExtensions.x-is-string}}
{{/vendorExtensions.x-to-string-support}}
{{^vendorExtensions.x-to-string-support}}
/// Converts the {{{classname}}} value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl ::std::string::ToString for {{{classname}}} {
    fn to_string(&self) -> String {
        // ToString for this model is not supported
        "".to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a {{{classname}}} value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl ::std::str::FromStr for {{{classname}}} {
    type Err = &'static str;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Err("Parsing {{{classname}}} is not supported")
    }
}
{{/vendorExtensions.x-to-string-support}}
{{/dataType}}
{{^dataType}}
{{#arrayModelType}}
{{#vendorExtensions}}{{#x-item-xml-name}}// Utility function for wrapping list elements when serializing xml
#[allow(non_snake_case)]
fn wrap_in_{{{x-item-xml-name}}}<S>(item: &Vec<{{{arrayModelType}}}>, serializer: S) -> std::result::Result<S::Ok, S::Error>
where
    S: serde::ser::Serializer,
{
    serde_xml_rs::wrap_primitives(item, serializer, "{{{x-item-xml-name}}}")
}

{{/x-item-xml-name}}
{{/vendorExtensions}}
{{! vec}}
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct {{{classname}}}(
{{#vendorExtensions}}
{{#x-item-xml-name}}
    #[serde(serialize_with = "wrap_in_{{{x-item-xml-name}}}")]
{{/x-item-xml-name}}
{{/vendorExtensions}}
    Vec<{{{arrayModelType}}}>
);

impl std::convert::From<Vec<{{{arrayModelType}}}>> for {{{classname}}} {
    fn from(x: Vec<{{{arrayModelType}}}>) -> Self {
        {{{classname}}}(x)
    }
}

impl std::convert::From<{{{classname}}}> for Vec<{{{arrayModelType}}}> {
    fn from(x: {{{classname}}}) -> Self {
        x.0
    }
}

impl std::iter::FromIterator<{{{arrayModelType}}}> for {{{classname}}} {
    fn from_iter<U: IntoIterator<Item={{{arrayModelType}}}>>(u: U) -> Self {
        {{{classname}}}(Vec::<{{{arrayModelType}}}>::from_iter(u))
    }
}

impl std::iter::IntoIterator for {{{classname}}} {
    type Item = {{{arrayModelType}}};
    type IntoIter = std::vec::IntoIter<{{{arrayModelType}}}>;

    fn into_iter(self) -> Self::IntoIter {
        self.0.into_iter()
    }
}

impl<'a> std::iter::IntoIterator for &'a {{{classname}}} {
    type Item = &'a {{{arrayModelType}}};
    type IntoIter = std::slice::Iter<'a, {{{arrayModelType}}}>;

    fn into_iter(self) -> Self::IntoIter {
        self.0.iter()
    }
}

impl<'a> std::iter::IntoIterator for &'a mut {{{classname}}} {
    type Item = &'a mut {{{arrayModelType}}};
    type IntoIter = std::slice::IterMut<'a, {{{arrayModelType}}}>;

    fn into_iter(self) -> Self::IntoIter {
        self.0.iter_mut()
    }
}

impl std::ops::Deref for {{{classname}}} {
    type Target = Vec<{{{arrayModelType}}}>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl std::ops::DerefMut for {{{classname}}} {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

/// Converts the {{{classname}}} value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for {{{classname}}} {
    fn to_string(&self) -> String {
        self.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a {{{classname}}} value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for {{{classname}}} {
    type Err = <{{{arrayModelType}}} as std::str::FromStr>::Err;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        let mut items = vec![];
        for item in s.split(',')
        {
            items.push(item.parse()?);
        }
        std::result::Result::Ok({{{classname}}}(items))
    }
}

{{/arrayModelType}}
{{^arrayModelType}}
{{! general struct}}
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
{{#xmlName}}
#[serde(rename = "{{{.}}}")]
{{/xmlName}}
pub struct {{{classname}}} {
{{#vars}}{{#description}}    /// {{{.}}}
{{/description}}{{#isEnum}}    // Note: inline enums are not fully supported by openapi-generator
{{/isEnum}}
    #[serde(rename = "{{{baseName}}}")]
{{#vendorExtensions}}
{{#x-item-xml-name}}
    #[serde(serialize_with = "wrap_in_{{{x-item-xml-name}}}")]
{{/x-item-xml-name}}
{{/vendorExtensions}}
{{#hasValidation}}
    #[validate(
        {{#maxLength}}
            {{#minLength}}
            length(min = {{minLength}}, max = {{maxLength}}),
            {{/minLength}}
            {{^minLength}}
            length(max = {{maxLength}}),
            {{/minLength}}
        {{/maxLength}}
        {{^maxLength}}
            {{#minLength}}
            length(min = {{minLength}}),
            {{/minLength}}
        {{/maxLength}}
        {{#pattern}}
          {{^isByteArray}}
           regex = "RE_{{#lambda.uppercase}}{{{classname}}}_{{{name}}}{{/lambda.uppercase}}",
          {{/isByteArray}}
          {{#isByteArray}}
           custom ="validate_byte_{{#lambda.lowercase}}{{{classname}}}_{{{name}}}{{/lambda.lowercase}}"
          {{/isByteArray}}
        {{/pattern}}
        {{#maximum}}
            {{#minimum}}
            range(min = {{minimum}}, max = {{maximum}}),
            {{/minimum}}
            {{^minimum}}
            range(max = {{maximum}}),
            {{/minimum}}
        {{/maximum}}
        {{#minimum}}
            {{^maximum}}
            range(min = {{minimum}}),
            {{/maximum}}
        {{/minimum}}
        {{#maxItems}}
            {{#minItems}}
            length(min = {{minItems}}, max = {{maxItems}}),
            {{/minItems}}
            {{^minItems}}
            length(max = {{maxItems}}),
            {{/minItems}}
        {{/maxItems}}
        {{^maxItems}}
            {{#minItems}}
            length(min = {{minItems}}),
            {{/minItems}}
        {{/maxItems}}
        )]
{{/hasValidation}}
{{#required}}
    pub {{{name}}}: {{{dataType}}},
{{/required}}
{{^required}}
{{#isNullable}}
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
{{/isNullable}}
    #[serde(skip_serializing_if="Option::is_none")]
    pub {{{name}}}: Option<{{{dataType}}}>,
{{/required}}

{{/vars}}
}

{{#vars}}
{{#hasValidation}}
{{#pattern}}
{{^isByteArray}}
lazy_static::lazy_static! {
    static ref RE_{{#lambda.uppercase}}{{{classname}}}_{{{name}}}{{/lambda.uppercase}}: regex::Regex = regex::Regex::new(r"{{ pattern }}").unwrap();
}
{{/isByteArray}}
{{#isByteArray}}
lazy_static::lazy_static! {
    static ref RE_{{#lambda.uppercase}}{{{classname}}}_{{{name}}}{{/lambda.uppercase}}: regex::bytes::Regex = regex::bytes::Regex::new(r"{{ pattern }}").unwrap();
}
fn validate_byte_{{#lambda.lowercase}}{{{classname}}}_{{{name}}}{{/lambda.lowercase}}(
    b: &swagger::ByteArray
) -> Result<(), validator::ValidationError> {
    if !RE_{{#lambda.uppercase}}{{{classname}}}_{{{name}}}{{/lambda.uppercase}}.is_match(b) {
        return Err(validator::ValidationError::new("Character not allowed"));
    }
    Ok(())
}
{{/isByteArray}}
{{/pattern}}
{{/hasValidation}}
{{/vars}}

impl {{{classname}}} {
    #[allow(clippy::new_without_default)]
    pub fn new({{#vars}}{{^defaultValue}}{{{name}}}: {{{dataType}}}, {{/defaultValue}}{{/vars}}) -> {{{classname}}} {
        {{{classname}}} {
{{#vars}}            {{#defaultValue}}{{{name}}}: {{{defaultValue}}}{{/defaultValue}}{{^defaultValue}}{{{name}}}{{/defaultValue}},
{{/vars}}
        }
    }
}

/// Converts the {{{classname}}} value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for {{{classname}}} {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
{{#vars}}
{{#isByteArray}}
            // Skipping byte array {{baseName}} in query parameter serialization
{{/isByteArray}}
{{^isByteArray}}
{{#isBinary}}
            // Skipping binary data {{baseName}} in query parameter serialization
{{/isBinary}}
{{^isBinary}}
{{#isMap}}
            // Skipping map {{baseName}} in query parameter serialization
{{/isMap}}
{{^isMap}}
{{^isPrimitiveType}}
            // Skipping non-primitive type {{baseName}} in query parameter serialization
{{/isPrimitiveType}}
{{#isPrimitiveType}}
{{#required}}
            Some("{{{baseName}}}".to_string()),
{{^isArray}}
{{#isNullable}}
            Some(self.{{{name}}}.as_ref().map_or("null".to_string(), |x| x.to_string())),
{{/isNullable}}
{{^isNullable}}
            Some(self.{{{name}}}.to_string()),
{{/isNullable}}
{{/isArray}}
{{#isArray}}
{{#isNullable}}
            Some(self.{{{name}}}.as_ref().map_or(vec!["null".to_string()], |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","))),
{{/isNullable}}
{{^isNullable}}
            Some(self.{{{name}}}.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
{{/isNullable}}
{{/isArray}}
{{/required}}
{{^required}}
            self.{{{name}}}.as_ref().map(|{{{name}}}| {
                [
                    "{{{baseName}}}".to_string(),
{{^isArray}}
{{#isNullable}}
                    {{{name}}}.as_ref().map_or("null".to_string(), |x| x.to_string()),
{{/isNullable}}
{{^isNullable}}
                    {{{name}}}.to_string(),
{{/isNullable}}
{{/isArray}}
{{#isArray}}
{{#isNullable}}
                    {{{name}}}.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
{{/isNullable}}
{{^isNullable}}
                    {{{name}}}.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
{{/isNullable}}
{{/isArray}}
                ].join(",")
            }),
{{/required}}
{{/isPrimitiveType}}
{{/isMap}}
{{/isBinary}}
{{/isByteArray}}
{{/vars}}
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a {{{classname}}} value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for {{{classname}}} {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            {{#vars}}
            pub {{{name}}}: Vec<{{{dataType}}}>,
            {{/vars}}
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing {{{classname}}}".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
          {{#vars}}
            {{#isBinary}}
                    "{{{baseName}}}" => return std::result::Result::Err("Parsing binary data in this style is not supported in {{{classname}}}".to_string()),
            {{/isBinary}}
            {{^isBinary}}
              {{#isByteArray}}
                    "{{{baseName}}}" => return std::result::Result::Err("Parsing binary data in this style is not supported in {{{classname}}}".to_string()),
              {{/isByteArray}}
              {{^isByteArray}}
                {{#isContainer}}
                    "{{{baseName}}}" => return std::result::Result::Err("Parsing a container in this style is not supported in {{{classname}}}".to_string()),
                {{/isContainer}}
                {{^isContainer}}
                  {{#isNullable}}
                    "{{{baseName}}}" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in {{{classname}}}".to_string()),
                  {{/isNullable}}
                  {{^isNullable}}
                    #[allow(clippy::redundant_clone)]
                    "{{{baseName}}}" => intermediate_rep.{{{name}}}.push(<{{{dataType}}} as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                  {{/isNullable}}
                {{/isContainer}}
              {{/isByteArray}}
            {{/isBinary}}
          {{/vars}}
                    _ => return std::result::Result::Err("Unexpected key while parsing {{{classname}}}".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok({{{classname}}} {
            {{#vars}}
            {{#isNullable}}
            {{{name}}}: std::result::Result::Err("Nullable types not supported in {{{classname}}}".to_string())?,
            {{/isNullable}}
            {{^isNullable}}
            {{{name}}}: intermediate_rep.{{{name}}}.into_iter().next(){{#required}}.ok_or_else(|| "{{{baseName}}} missing in {{{classname}}}".to_string())?{{/required}},
            {{/isNullable}}
            {{/vars}}
        })
    }
}
{{/arrayModelType}}
{{/dataType}}
{{/isEnum}}

// Methods for converting between header::IntoHeaderValue<{{{classname}}}> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<{{{classname}}}>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<{{{classname}}}>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for {{classname}} - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<{{{classname}}}> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <{{{classname}}} as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into {{classname}} - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Vec<{{{classname}}}>>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_values: header::IntoHeaderValue<Vec<{{{classname}}}>>) -> std::result::Result<Self, Self::Error> {
        let hdr_values : Vec<String> = hdr_values.0.into_iter().map(|hdr_value| {
            hdr_value.to_string()
        }).collect();

        match hyper::header::HeaderValue::from_str(&hdr_values.join(", ")) {
           std::result::Result::Ok(hdr_value) => std::result::Result::Ok(hdr_value),
           std::result::Result::Err(e) => std::result::Result::Err(format!("Unable to convert {:?} into a header - {}",
               hdr_values, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Vec<{{{classname}}}>> {
    type Error = String;

    fn try_from(hdr_values: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_values.to_str() {
            std::result::Result::Ok(hdr_values) => {
                let hdr_values : std::vec::Vec<{{{classname}}}> = hdr_values
                .split(',')
                .filter_map(|hdr_value| match hdr_value.trim() {
                    "" => std::option::Option::None,
                    hdr_value => std::option::Option::Some({
                        match <{{{classname}}} as std::str::FromStr>::from_str(hdr_value) {
                            std::result::Result::Ok(value) => std::result::Result::Ok(value),
                            std::result::Result::Err(err) => std::result::Result::Err(
                                format!("Unable to convert header value '{}' into {{classname}} - {}",
                                    hdr_value, err))
                        }
                    })
                }).collect::<std::result::Result<std::vec::Vec<_>, String>>()?;

                std::result::Result::Ok(header::IntoHeaderValue(hdr_values))
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!("Unable to parse header: {:?} as a string - {}",
                hdr_values, e)),
        }
    }
}
{{#usesXml}}
{{#usesXmlNamespaces}}
{{#xmlNamespace}}

impl {{{classname}}} {
    /// Associated constant for this model's XML namespace.
    #[allow(dead_code)]
    pub const NAMESPACE: &'static str = "{{{xmlNamespace}}}";
}
{{/xmlNamespace}}
{{/usesXmlNamespaces}}

impl {{{classname}}} {
    /// Helper function to allow us to convert this model to an XML string.
    /// Will panic if serialisation fails.
    #[allow(dead_code)]
    pub(crate) fn as_xml(&self) -> String {
        {{#xmlNamespace}}
        let mut namespaces = std::collections::BTreeMap::new();
        // An empty string is used to indicate a global namespace in xmltree.
        namespaces.insert("".to_string(), Self::NAMESPACE.to_string());
        serde_xml_rs::to_string_with_namespaces(&self, namespaces).expect("impossible to fail to serialize")
        {{/xmlNamespace}}
        {{^xmlNamespace}}
        serde_xml_rs::to_string(&self).expect("impossible to fail to serialize")
        {{/xmlNamespace}}
    }
}
{{/usesXml}}
{{/model}}
{{/models}}
openapi.mustache:
{{{openapi-yaml}}}
README.md:
# Rust Server Generator Templates

The Rust Server Generator templates use Mustache Partials.

The following tree shows which templates include which:

- `api_doc.mustache`
- `bin-cli.mustache`
- `cargo-config`
- `Cargo.mustache`
- `context.mustache`
- `client-callbacks-mod.mustache`
  - `server-imports.mustache`
  - `server-make-service.mustache`
  - `server-service-footer.mustache`
  - `server-service-header.mustache`
  - `server-operation.mustache`
- `client-mod.mustache`
  - `client-imports.mustache`
  - `client-operation.mustache`
- `example-ca.pem`
- `example-client-main.mustache`
- `example-client-server.mustache`
- `example-server-chain.pem`
- `example-server-common.mustache`
- `example-server-key.pem`
- `example-server-main.mustache`
- `example-server-server.mustache`
  - `example-server-operation.mustache`
- `gitignore`
- `header.mustache`
- `lib.mustache`
  - `response.mustache`
- `model_doc.mustache`
- `models.mustache`
- `openapi.mustache`
- `README.mustache`
- `server-callbacks.mustache`
  - `client-imports.mustache`
  - `client-operation.mustache`
- `server-service-header.mustache`
- `server-mod.mustache`
  - `server-imports.mustache`
  - `server-make-service.mustache`
  - `server-service-footer.mustache`
  - `server-service-header.mustache`
  - `server-operation.mustache`
- `server-paths.mustache`
README.mustache:
# Rust API for {{{packageName}}}

{{#appDescriptionWithNewLines}}
{{{.}}}
{{/appDescriptionWithNewLines}}

## Overview

This client/server was generated by the [openapi-generator]
(https://openapi-generator.tech) project.  By using the
[OpenAPI-Spec](https://github.com/OAI/OpenAPI-Specification) from a remote
server, you can easily generate a server stub.

To see how to make this your own, look here:

[README]((https://openapi-generator.tech))

- API version: {{{appVersion}}}
{{^hideGenerationTimestamp}}
- Build date: {{{generatedDate}}}
{{/hideGenerationTimestamp}}
- Generator version: {{generatorVersion}}

{{#infoUrl}}For more information, please visit [{{{infoUrl}}}]({{{infoUrl}}}){{/infoUrl}}

This autogenerated project defines an API crate `{{{packageName}}}` which contains:
* An `Api` trait defining the API in Rust.
* Data types representing the underlying data model.
* A `Client` type which implements `Api` and issues HTTP requests for each operation.
* A router which accepts HTTP requests and invokes the appropriate `Api` method for each operation.
* A CLI tool to drive basic API operations from the command line.

It also contains an example server and client which make use of `{{{packageName}}}`:

* The example server starts up a web server using the `{{{packageName}}}`
    router, and supplies a trivial implementation of `Api` which returns failure
    for every operation.
* The example client provides a CLI which lets you invoke
    any single operation on the `{{{packageName}}}` client by passing appropriate
    arguments on the command line.

You can use the example server and client as a basis for your own code.
See below for [more detail on the examples](#using-the-generated-library).

## CLI

Run the included CLI tool with:

```
cargo run --bin cli --features=cli
```

To pass in arguments, put them after `--`, for example:

```
cargo run --bin cli --features=cli -- --help
```

See the help text for available options.

To build a standalone tool, use:

```
cargo build --bin cli --features=cli --release
```

You'll find the binary at `target/release/cli`.

## Examples

Run examples with:

```
cargo run --example <example-name>
```

To pass in arguments to the examples, put them after `--`, for example:

```
cargo run --example client -- --help
```

### Running the example server
To run the server, follow these simple steps:

```
cargo run --example server
```

### Running the example client
To run a client, follow one of the following simple steps:

```
{{#apiInfo}}
  {{#apis}}
    {{#operations}}
      {{#operation}}
        {{#vendorExtensions}}
          {{^x-no-client-example}}
cargo run --example client {{{operationId}}}
          {{/x-no-client-example}}
        {{/vendorExtensions}}
      {{/operation}}
    {{/operations}}
  {{/apis}}
{{/apiInfo}}
```

### HTTPS
The examples can be run in HTTPS mode by passing in the flag `--https`, for example:

```
cargo run --example server -- --https
```

This will use the keys/certificates from the examples directory. Note that the
server chain is signed with `CN=localhost`.

## Using the generated library

The generated library has a few optional features that can be activated through Cargo.

* `server`
    * This defaults to enabled and creates the basic skeleton of a server implementation based on hyper
    * To create the server stack you'll need to provide an implementation of the API trait to provide the server function.
* `client`
    * This defaults to enabled and creates the basic skeleton of a client implementation based on hyper
    * The constructed client implements the API trait by making remote API call.
* `conversions`
    * This defaults to disabled and creates extra derives on models to allow "transmogrification" between objects of structurally similar types.
* `cli`
    * This defaults to disabled and is required for building the included CLI tool.

See https://doc.rust-lang.org/cargo/reference/manifest.html#the-features-section for how to use features in your `Cargo.toml`.

## Documentation for API Endpoints

All URIs are relative to *{{{basePath}}}*

Method | HTTP request | Description
------------- | ------------- | -------------
{{#apiInfo}}{{#apis}}{{#operations}}{{#operation}}[**{{{operationIdOriginal}}}**]({{{apiDocPath}}}{{classname}}_api.md#{{{operationIdOriginal}}}) | **{{{httpMethod}}}** {{{path}}} | {{{summary}}}
{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}

## Documentation For Models

{{#models}}{{#model}} - [{{{classname}}}]({{{modelDocPath}}}{{{classname}}}.md)
{{/model}}{{/models}}

## Documentation For Authorization
{{^authMethods}}Endpoints do not require authorization.{{/authMethods}}
{{#hasAuthMethods}}Authentication schemes defined for the API:{{/hasAuthMethods}}
{{#authMethods}}
### {{{name}}}
{{#isApiKey}}- **Type**: API key

Example
```
	{{! TODO: Add API Key example }}
```
{{/isApiKey}}
{{#isBasicBasic}}- **Type**: HTTP basic authentication

Example
```
	{{! TODO: Add HTTP basic authentication }}
```
{{/isBasicBasic}}
{{#isBasicBearer}}- **Type**: Bearer token authentication

Example
```
	{{! TODO: Add Bearer token authentication }}
```
{{/isBasicBearer}}
{{#isHttpSignature}}- **Type**: HTTP signature authentication
{{/isHttpSignature}}
{{#isOAuth}}- **Type**: OAuth
- **Flow**: {{{flow}}}
- **Authorization URL**: {{{authorizationUrl}}}
- **Scopes**: {{^scopes}}N/A{{/scopes}}
{{#scopes}} - **{{{scope}}}**: {{{description}}}
{{/scopes}}

Example
```
	{{! TODO: OAuth example }}
```

Or via OAuth2 module to automatically refresh tokens and perform user authentication.
```
	{{! TODO: OAuth example }}
```
{{/isOAuth}}
{{/authMethods}}

## Author

{{#apiInfo}}{{#apis}}{{#-last}}{{{infoEmail}}}
{{/-last}}{{/apis}}{{/apiInfo}}
response.mustache:
#[derive(Debug, PartialEq, Serialize, Deserialize)]
{{#vendorExtensions.x-must-use-response}}
#[must_use]
{{/vendorExtensions.x-must-use-response}}
pub enum {{{operationId}}}Response {
{{#responses}}
  {{#message}}
    /// {{{.}}}{{/message}}
    {{#vendorExtensions}}
    {{{x-response-id}}}
    {{/vendorExtensions}}
    {{^dataType}}
      {{#hasHeaders}}
    {
      {{/hasHeaders}}
    {{/dataType}}
    {{#dataType}}
      {{^hasHeaders}}
        {{#vendorExtensions}}
          {{#x-produces-plain-text}}
    (String)
          {{/x-produces-plain-text}}
          {{^x-produces-plain-text}}
    ({{{dataType}}})
          {{/x-produces-plain-text}}
        {{/vendorExtensions}}
      {{/hasHeaders}}
      {{#hasHeaders}}
    {
        {{#vendorExtensions}}
          {{#x-produces-plain-text}}
        body: String,
            {{/x-produces-plain-text}}
            {{^x-produces-plain-text}}
        body: {{{dataType}}},
            {{/x-produces-plain-text}}
          {{/vendorExtensions}}
      {{/hasHeaders}}
    {{/dataType}}
    {{#headers}}
        {{{name}}}:
      {{^required}}
        Option<
      {{/required}}
        {{{dataType}}}
      {{^required}}
        >
      {{/required}}
        {{^-last}}
        ,
        {{/-last}}
      {{#-last}}
    }
      {{/-last}}
    {{/headers}}
    {{^-last}}
    ,
    {{/-last}}
{{/responses}}
}
server-callbacks.mustache:
{{>client-imports}}
use crate::CallbackApi;
{{#apiInfo}}
  {{#apis}}
    {{#operations}}
      {{#operation}}
        {{#callbacks}}
          {{#urls}}
            {{#requests}}
use crate::{{{operationId}}}Response;
            {{/requests}}
          {{/urls}}
        {{/callbacks}}
      {{/operation}}
    {{/operations}}
  {{/apis}}
{{/apiInfo}}

/// A client that implements the API by making HTTP calls out to a server.
pub struct Client<S, C> where
    S: Service<
           (Request<Body>, C),
           Response=Response<Body>,
           Error=hyper::Error> + Clone + Send + Sync,
    S::Future: Send + 'static,
    C: Clone + Send + Sync + 'static
{
    /// Inner service
    client_service: S,

    /// Marker
    marker: PhantomData<fn(C)>,
}

impl<S, C> fmt::Debug for Client<S, C> where
    S: Service<
           (Request<Body>, C),
           Response=Response<Body>,
           Error=hyper::Error> + Clone + Send + Sync,
    S::Future: Send + 'static,
    C: Clone + Send + Sync + 'static
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Client")
    }
}

impl<S, C> Clone for Client<S, C> where
    S: Service<
           (Request<Body>, C),
           Response=Response<Body>,
           Error=hyper::Error> + Clone + Send + Sync,
    S::Future: Send + 'static,
    C: Clone + Send + Sync + 'static
{
    fn clone(&self) -> Self {
        Self {
            client_service: self.client_service.clone(),
            marker: PhantomData,
        }
    }
}

impl<Connector, C> Client<DropContextService<hyper::client::Client<Connector, Body>, C>, C> where
    Connector: hyper::client::connect::Connect + Clone + Send + Sync + 'static,
    C: Clone + Send + Sync + 'static
{
    /// Create a client with a custom implementation of hyper::client::Connect.
    ///
    /// Intended for use with custom implementations of connect for e.g. protocol logging
    /// or similar functionality which requires wrapping the transport layer. When wrapping a TCP connection,
    /// this function should be used in conjunction with `swagger::Connector::builder()`.
    ///
    /// For ordinary tcp connections, prefer the use of `new_http`, `new_https`
    /// and `new_https_mutual`, to avoid introducing a dependency on the underlying transport layer.
    ///
    /// # Arguments
    ///
    /// * `connector` - Implementation of `hyper::client::Connect` to use for the client
    pub fn new_with_connector(connector: Connector) -> Self
    {
        let client_service = hyper::client::Client::builder().build(connector);
        let client_service = DropContextService::new(client_service);

        Self {
            client_service,
            marker: PhantomData,
        }
    }
}

impl<C> Client<DropContextService<hyper::client::Client<hyper::client::HttpConnector, Body>, C>, C> where
    C: Clone + Send + Sync + 'static
{
    /// Create an HTTP client.
    pub fn new_http() -> Self {
        let http_connector = Connector::builder().build();
        Self::new_with_connector(http_connector)
    }
}

#[cfg(any(target_os = "macos", target_os = "windows", target_os = "ios"))]
type HttpsConnector = hyper_tls::HttpsConnector<hyper::client::HttpConnector>;

#[cfg(not(any(target_os = "macos", target_os = "windows", target_os = "ios")))]
type HttpsConnector = hyper_openssl::HttpsConnector<hyper::client::HttpConnector>;

impl<C> Client<DropContextService<hyper::client::Client<HttpsConnector, Body>, C>, C> where
    C: Clone + Send + Sync + 'static
{
    /// Create a client with a TLS connection to the server.
    #[cfg(any(target_os = "macos", target_os = "windows", target_os = "ios"))]
    pub fn new_https()  -> Result<Self, native_tls::Error>
    {
        let https_connector = Connector::builder().https().build()?;
        Ok(Self::new_with_connector(https_connector))
    }

    /// Create a client with a TLS connection to the server.
    #[cfg(not(any(target_os = "macos", target_os = "windows", target_os = "ios")))]
    pub fn new_https() -> Result<Self, openssl::error::ErrorStack>
    {
        let https_connector = Connector::builder().https().build()?;
        Ok(Self::new_with_connector(https_connector))
    }

    /// Create a client with a TLS connection to the server, pinning the certificate
    ///
    /// # Arguments
    /// * `ca_certificate` - Path to CA certificate used to authenticate the server
    #[cfg(not(any(target_os = "macos", target_os = "windows", target_os = "ios")))]
    pub fn new_https_pinned<CA>(
        ca_certificate: CA,
    ) -> Result<Self, openssl::error::ErrorStack> where
        CA: AsRef<Path>,
    {
        let https_connector = Connector::builder()
            .https()
            .pin_server_certificate(ca_certificate)
            .build()?;
        Ok(Self::new_with_connector(https_connector))
    }

    /// Create a client with a mutually authenticated TLS connection to the server.
    ///
    /// # Arguments
    /// * `ca_certificate` - Path to CA certificate used to authenticate the server
    /// * `client_key` - Path to the client private key
    /// * `client_certificate` - Path to the client's public certificate associated with the private key
    #[cfg(not(any(target_os = "macos", target_os = "windows", target_os = "ios")))]
    pub fn new_https_mutual<CA, K, D>(
        ca_certificate: CA,
        client_key: K,
        client_certificate: D,
    ) -> Result<Self, openssl::error::ErrorStack>
    where
        CA: AsRef<Path>,
        K: AsRef<Path>,
        D: AsRef<Path>,
    {
        let https_connector = Connector::builder()
            .https()
            .pin_server_certificate(ca_certificate)
            .client_authentication(client_key, client_certificate)
            .build()?;
        Ok(Self::new_with_connector(https_connector))
    }
}

impl<S, C> Client<S, C> where
    S: Service<
           (Request<Body>, C),
           Response=Response<Body>,
           Error=hyper::Error> + Clone + Send + Sync,
    S::Future: Send + 'static,
    C: Clone + Send + Sync + 'static
{
    /// Constructor for creating a `Client` by passing in a pre-made `swagger::Service`
    ///
    /// This allows adding custom wrappers around the underlying transport, for example for logging.
    pub fn new_with_client_service(
        client_service: S,
    ) -> Self {
        Client {
            client_service,
            marker: PhantomData,
        }
    }
}

#[async_trait]
impl<S, C> CallbackApi<C> for Client<S, C> where
    S: Service<
           (Request<Body>, C),
           Response=Response<Body>,
           Error=hyper::Error> + Clone + Send + Sync,
    S::Future: Send + 'static,
    S::Error: Into<crate::ServiceError> + fmt::Display,
    C: Has<XSpanIdString> {{#hasAuthMethods}}+ Has<Option<AuthData>>{{/hasAuthMethods}} + Clone + Send + Sync,
{
    fn poll_ready(&self, cx: &mut Context) -> Poll<Result<(), crate::ServiceError>> {
        match self.client_service.clone().poll_ready(cx) {
            Poll::Ready(Err(e)) => Poll::Ready(Err(Box::new(e))),
            Poll::Ready(Ok(o)) => Poll::Ready(Ok(o)),
            Poll::Pending => Poll::Pending,
        }
    }

{{#apiInfo}}
  {{#apis}}
    {{#operations}}
      {{#operation}}
        {{#callbacks}}
          {{#urls}}
            {{#requests}}
{{>client-operation}}
            {{/requests}}
          {{/urls}}
        {{/callbacks}}
      {{/operation}}
    {{/operations}}
  {{/apis}}
{{/apiInfo}}
}
server-imports.mustache:
use bytes::Bytes;
use http_body_util::{BodyExt, Full};
use hyper::body::Incoming;

use futures::{future, future::BoxFuture, Stream, stream, future::FutureExt, stream::TryStreamExt};
use hyper::{Request, Response, StatusCode, HeaderMap};
use hyper::header::{HeaderName, HeaderValue, CONTENT_TYPE};
use log::warn;
#[allow(unused_imports)]
use std::convert::{TryFrom, TryInto};
use std::error::Error;
use std::future::Future;
use std::marker::PhantomData;
use std::task::{Context, Poll};
// use swagger::{ApiError, Has, RequestParser, XSpanIdString};
// pub use swagger::auth::Authorization;
// use swagger::auth::Scopes;
use url::form_urlencoded;
{{#apiUsesMultipartRelated}}
use hyper_0_10::header::{Headers, ContentType};
use mime_0_2::{TopLevel, SubLevel, Mime as Mime2};
use mime_multipart::{read_multipart_body, Node, Part};
{{/apiUsesMultipartRelated}}
{{#apiUsesMultipartFormData}}
use multipart::server::Multipart;
use multipart::server::save::{PartialReason, SaveResult};
{{/apiUsesMultipartFormData}}

#[allow(unused_imports)]
use crate::{models, header, AuthenticationApi};

pub use crate::context;

type ServiceFuture = BoxFuture<'static, Result<Response<Full<Bytes>>, crate::ServiceError>>;server-make-service.mustache:

pub struct MakeService<T, C> where
    T: Api<C> + Clone + Send + 'static,
    C: Has<XSpanIdString> {{#hasAuthMethods}}+ Has<Option<Authorization>>{{/hasAuthMethods}} + Send + Sync + 'static
{
    api_impl: T,
{{#apiUsesMultipartFormData}}
    multipart_form_size_limit: Option<u64>,
{{/apiUsesMultipartFormData}}
    marker: PhantomData<C>,
}

impl<T, C> MakeService<T, C> where
    T: Api<C> + Clone + Send + 'static,
    C: Has<XSpanIdString> {{#hasAuthMethods}}+ Has<Option<Authorization>>{{/hasAuthMethods}} + Send + Sync + 'static
{
    pub fn new(api_impl: T) -> Self {
        MakeService {
            api_impl,
{{#apiUsesMultipartFormData}}
            multipart_form_size_limit: Some(8 * 1024 * 1024),
{{/apiUsesMultipartFormData}}
            marker: PhantomData
        }
    }
{{#apiUsesMultipartFormData}}

    /// Configure size limit when inspecting a multipart/form body.
    ///
    /// Default is 8 MiB.
    ///
    /// Set to None for no size limit, which presents a Denial of Service attack risk.
    pub fn multipart_form_size_limit(mut self, multipart_form_size_limit: Option<u64>) -> Self {
        self.multipart_form_size_limit = multipart_form_size_limit;
        self
    }
{{/apiUsesMultipartFormData}}
}

impl<T, C, Target> hyper::service::Service<Target> for MakeService<T, C> where
    T: Api<C> + Clone + Send + 'static,
    C: Has<XSpanIdString> {{#hasAuthMethods}}+ Has<Option<Authorization>>{{/hasAuthMethods}} + Send + Sync + 'static
{
    type Response = Service<T, C>;
    type Error = crate::ServiceError;
    type Future = future::Ready<Result<Self::Response, Self::Error>>;

    fn call(&self, target: Target) -> Self::Future {
        let service = Service::new(self.api_impl.clone()){{^apiUsesMultipartFormData}};{{/apiUsesMultipartFormData}}
{{#apiUsesMultipartFormData}}
            .multipart_form_size_limit(self.multipart_form_size_limit);
{{/apiUsesMultipartFormData}}

        future::ok(service)
    }
}server-mod.mustache:
{{>server-imports}}
use crate::{Api{{#apiInfo}}{{#apis}}{{#operations}}{{#operation}},
     {{{operationId}}}Response{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}
};

mod server_auth;

{{#hasCallbacks}}
pub mod callbacks;

{{/hasCallbacks}}
{{>server-paths}}
{{>server-make-service}}
{{>server-service-header}}
{{#apiInfo}}
  {{#apis}}
    {{#operations}}
      {{#operation}}
{{>server-operation}}
      {{/operation}}
    {{/operations}}
  {{/apis}}
{{/apiInfo}}
{{#pathSet}}
            _ if path.matched(paths::ID_{{PATH_ID}}) => method_not_allowed(),
{{/pathSet}}
{{>server-service-footer}}
/// Request parser for `Api`.
pub struct ApiRequestParser;
impl<T> RequestParser<T> for ApiRequestParser {
    fn parse_operation_id(request: &Request<T>) -> Option<&'static str> {
        let path = paths::GLOBAL_REGEX_SET.matches(request.uri().path());
        match *request.method() {
{{#apiInfo}}
  {{#apis}}
    {{#operations}}
      {{#operation}}
            // {{{operationId}}} - {{{httpMethod}}} {{{path}}}
            hyper::Method::{{{vendorExtensions.x-http-method}}} if path.matched(paths::ID_{{{vendorExtensions.x-path-id}}}) => Some("{{{operationId}}}"),
      {{/operation}}
    {{/operations}}
  {{/apis}}
{{/apiInfo}}
            _ => None,
        }
    }
}
server-operation.mustache:
            // {{{operationId}}} - {{{httpMethod}}} {{{path}}}
            hyper::Method::{{vendorExtensions.x-http-method}} if path.matched(paths::ID_{{vendorExtensions.x-path-id}}) => {
{{#hasAuthMethods}}
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Full::new(Bytes::from("Unauthenticated")))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };
                    {{#authMethods}}
                    {{#isOAuth}}

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            {{#scopes}}
                            "{{{scope}}}".to_string(), // {{{description}}}
                            {{/scopes}}
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Full::new(Bytes::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                )))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                    {{/isOAuth}}
                    {{/authMethods}}
                }

{{/hasAuthMethods}}
{{#vendorExtensions}}
  {{#x-has-path-params}}
                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_{{{x-path-id}}}
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE {{{x-path-id}}} in set but failed match against \"{}\"", path, paths::REGEX_{{{x-path-id}}}.as_str())
                    );

  {{/x-has-path-params}}
{{/vendorExtensions}}
{{#pathParams}}
                let param_{{{paramName}}} = match percent_encoding::percent_decode(path_params["{{{baseName}}}"].as_bytes()).decode_utf8() {
                    Ok(param_{{{paramName}}}) => match param_{{{paramName}}}.parse::<{{{dataType}}}>() {
                        Ok(param_{{{paramName}}}) => param_{{{paramName}}},
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Full::new(Bytes::from(format!("Couldn't parse path parameter {{{baseName}}}: {}", e))))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Full::new(Bytes::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["{{{baseName}}}"]))))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

{{/pathParams}}
{{#vendorExtensions}}
  {{#x-callback-params}}
                let callback_{{.}} = path_params["{{{.}}}"].to_string();
  {{/x-callback-params}}
{{/vendorExtensions}}
{{#headerParams}}
  {{#-first}}
                // Header parameters
  {{/-first}}
                let param_{{{paramName}}} = headers.get(HeaderName::from_static("{{{nameInLowerCase}}}"));

                let param_{{{paramName}}} = match param_{{{paramName}}} {
                    Some(v) => match header::IntoHeaderValue::<{{{dataType}}}>::try_from((*v).clone()) {
                        Ok(result) =>
{{#required}}
                            result.0,
{{/required}}
{{^required}}
                            Some(result.0),
{{/required}}
                        Err(err) => {
                            return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Full::new(Bytes::from(format!("Invalid header {{{baseName}}} - {}", err))))
                                        .expect("Unable to create Bad Request response for invalid header {{{baseName}}}"));

                        },
                    },
                    None => {
{{#required}}
                        return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Full::new(Bytes::from("Missing required header {{{baseName}}}")))
                                        .expect("Unable to create Bad Request response for missing required header {{{baseName}}}"));
{{/required}}
{{^required}}
                        None
{{/required}}
                    }
                };
  {{#-last}}

  {{/-last}}
{{/headerParams}}
{{#queryParams}}
  {{#-first}}
                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
  {{/-first}}
                let param_{{{paramName}}} = query_params.iter().filter(|e| e.0 == "{{{baseName}}}").map(|e| e.1.clone())
  {{#isArray}}
    {{^vendorExtensions.x-consumes-json}}
                    .filter_map(|param_{{{paramName}}}| param_{{{paramName}}}.parse().ok())
                    .collect::<Vec<_>>();
      {{^required}}
                let param_{{{paramName}}} = if !param_{{{paramName}}}.is_empty() {
                    Some(param_{{{paramName}}})
                } else {
                    None
                };
      {{/required}}
    {{/vendorExtensions.x-consumes-json}}
    {{#vendorExtensions.x-consumes-json}}
                    .next();
                let param_{{{paramName}}} = match param_{{{paramName}}} {
                    Some(param_{{{paramName}}}) => {
                        let param_{{{paramName}}} =
                            serde_json::from_str::<{{{dataType}}}>
                                (&param_{{{paramName}}});
                        match param_{{{paramName}}} {
                            Ok(param_{{{paramName}}}) => Some(param_{{{paramName}}}),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Full::new(Bytes::from(format!("Couldn't parse query parameter {{{baseName}}} - doesn't match schema: {}", e))))
                                .expect("Unable to create Bad Request response for invalid query parameter {{{baseName}}}")),
                        }
                    },
                    None => None,
                };
      {{#required}}
                let param_{{{paramName}}} = match param_{{{paramName}}} {
                    Some(param_{{{paramName}}}) => param_{{{paramName}}},
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Full::new(Bytes::from("Missing required query parameter {{{baseName}}}")))
                        .expect("Unable to create Bad Request response for missing query parameter {{{baseName}}}")),
                };
      {{/required}}
    {{/vendorExtensions.x-consumes-json}}
  {{/isArray}}
  {{^isArray}}
                    .next();
                let param_{{{paramName}}} = match param_{{{paramName}}} {
                    Some(param_{{{paramName}}}) => {
                        let param_{{{paramName}}} =
    {{#vendorExtensions.x-consumes-json}}
                            serde_json::from_str::<{{{dataType}}}>
    {{/vendorExtensions.x-consumes-json}}
    {{^vendorExtensions.x-consumes-json}}
                            <{{{dataType}}} as std::str::FromStr>::from_str
    {{/vendorExtensions.x-consumes-json}}
                                (&param_{{{paramName}}});
                        match param_{{{paramName}}} {
                            Ok(param_{{{paramName}}}) => Some(param_{{{paramName}}}),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Full::new(Bytes::from(format!("Couldn't parse query parameter {{{baseName}}} - doesn't match schema: {}", e))))
                                .expect("Unable to create Bad Request response for invalid query parameter {{{baseName}}}")),
                        }
                    },
                    None => None,
                };
    {{#required}}
                let param_{{{paramName}}} = match param_{{{paramName}}} {
                    Some(param_{{{paramName}}}) => param_{{{paramName}}},
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Full::new(Bytes::from("Missing required query parameter {{{baseName}}}")))
                        .expect("Unable to create Bad Request response for missing query parameter {{{baseName}}}")),
                };
    {{/required}}
  {{/isArray}}
  {{#-last}}

  {{/-last}}
{{/queryParams}}
{{#vendorExtensions.x-has-request-body}}
                // Handle body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result: Result<hyper::body::Bytes, hyper::Error> = body.collect().await
                    .map(|collected| collected.to_bytes());
                match result {
                     Ok(body) => {
  {{^vendorExtensions.x-consumes-multipart-form}}
    {{^vendorExtensions.x-consumes-form}}
      {{^bodyParam.vendorExtensions.x-consumes-plain-text}}
                                let mut unused_elements : Vec<String> = vec![];
      {{/bodyParam.vendorExtensions.x-consumes-plain-text}}
    {{/vendorExtensions.x-consumes-form}}
  {{/vendorExtensions.x-consumes-multipart-form}}
{{>server-request-body-instance}}
{{/vendorExtensions.x-has-request-body}}
                                let result = api_impl.{{#vendorExtensions}}{{{x-operation-id}}}{{/vendorExtensions}}(
                                        {{#vendorExtensions}}
                                          {{#x-callback-params}}
                                            callback_{{.}},
                                          {{/x-callback-params}}
                                        {{/vendorExtensions}}
                                        {{#allParams}}
                                            param_{{{paramName}}}{{#isArray}}.as_ref(){{/isArray}},
                                        {{/allParams}}
                                        &context
                                    ).await;
                                let mut response = Response::new(Full::new(Bytes::new()));
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

{{#vendorExtensions.x-has-request-body}}
  {{^vendorExtensions.x-consumes-multipart-form}}
    {{^vendorExtensions.x-consumes-form}}
      {{^bodyParam.vendorExtensions.x-consumes-plain-text}}
                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }
      {{/bodyParam.vendorExtensions.x-consumes-plain-text}}
    {{/vendorExtensions.x-consumes-form}}
  {{/vendorExtensions.x-consumes-multipart-form}}
{{/vendorExtensions.x-has-request-body}}
                                        match result {
                                            Ok(rsp) => match rsp {
{{#responses}}
                                                {{{operationId}}}Response::{{#vendorExtensions}}{{x-response-id}}{{/vendorExtensions}}
{{#dataType}}
{{^headers}}
                                                    (body)
{{/headers}}
{{#headers}}
{{#-first}}
                                                    {
                                                        body,
{{/-first}}
                                                        {{{name}}}{{^-last}},{{/-last}}
{{#-last}}
                                                    }
{{/-last}}
{{/headers}}
{{/dataType}}
{{^dataType}}
{{#headers}}
{{#-first}}
                                                    {
{{/-first}}
                                                        {{{name}}}{{^-last}},{{/-last}}
{{#-last}}
                                                    }
{{/-last}}
{{/headers}}
{{/dataType}}
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16({{{code}}}).expect("Unable to turn {{{code}}} into a StatusCode");
{{#headers}}

  {{^required}}
                                                    if let Some({{{name}}}) = {{{name}}} {
  {{/required}}
                                                    let {{{name}}} = match header::IntoHeaderValue({{{name}}}).try_into() {
                                                        Ok(val) => val,
                                                        Err(e) => {
                                                            return Ok(Response::builder()
                                                                    .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                                    .body(Full::new(Bytes::from(format!("An internal server error occurred handling {{name}} header - {}", e))))
                                                                    .expect("Unable to create Internal Server Error for invalid response header"))
                                                        }
                                                    };

                                                    response.headers_mut().insert(
                                                        HeaderName::from_static("{{{nameInLowerCase}}}"),
                                                        {{name}}
                                                    );
  {{^required}}
                                                    }
  {{/required}}
{{/headers}}
{{>server-response-body-instance}}
                                                },
{{/responses}}
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Full::new(Bytes::from("An internal error occurred"));
                                            },
                                        }

                                        Ok(response)
{{#vendorExtensions.x-has-request-body}}
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Full::new(Bytes::from(format!("Unable to read body: {}", e))))
                                                .expect("Unable to create Bad Request response due to unable to read body")),
                        }
{{/vendorExtensions.x-has-request-body}}
            },
server-paths.mustache:
mod paths {
    use lazy_static::lazy_static;

    lazy_static! {
        pub static ref GLOBAL_REGEX_SET: regex::RegexSet = regex::RegexSet::new(vec![
{{#pathSet}}
            r"^{{{basePathWithoutHost}}}{{{pathRegEx}}}"{{^-last}},{{/-last}}
{{/pathSet}}
        ])
        .expect("Unable to create global regex set");
    }
{{#pathSet}}
    pub(crate) static ID_{{{PATH_ID}}}: usize = {{{index}}};
{{#hasPathParams}}
    lazy_static! {
        pub static ref REGEX_{{{PATH_ID}}}: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^{{{basePathWithoutHost}}}{{{pathRegEx}}}")
                .expect("Unable to create regex for {{{PATH_ID}}}");
    }
{{/hasPathParams}}
{{/pathSet}}
}
server-request-body-basic.mustache:
        {{#vendorExtensions}}
                                let param_{{{paramName}}}: Option<{{{dataType}}}> = if !body.is_empty() {
          {{#x-consumes-xml}}
                                    let deserializer = &mut serde_xml_rs::de::Deserializer::new_from_reader(&*body);
          {{/x-consumes-xml}}
          {{#x-consumes-json}}
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&*body);
          {{/x-consumes-json}}
          {{^x-consumes-plain-text}}
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_{{{paramName}}}) => param_{{{paramName}}},
            {{#required}}
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Full::new(Bytes::from(format!("Couldn't parse body parameter {{{baseName}}} - doesn't match schema: {}", e))))
                                                        .expect("Unable to create Bad Request response for invalid body parameter {{{baseName}}} due to schema")),
            {{/required}}
            {{^required}}
                                        Err(_) => None,
            {{/required}}
                                    }
          {{/x-consumes-plain-text}}
          {{#x-consumes-plain-text}}
            {{#isByteArray}}
                                    // Some(swagger::ByteArray(body.to_vec()))
            {{/isByteArray}}
            {{#isString}}
                                    match String::from_utf8(body.to_vec()) {
                                        Ok(param_{{{paramName}}}) => Some(param_{{{paramName}}}),
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Full::new(Bytes::from(format!("Couldn't parse body parameter {{{baseName}}} - not valid UTF-8: {}", e))))
                                                        .expect("Unable to create Bad Request response for invalid body parameter {{{baseName}}} due to UTF-8")),
                                    }
            {{/isString}}
          {{/x-consumes-plain-text}}
        {{/vendorExtensions}}
                                } else {
                                    None
                                };
        {{#required}}
                                let param_{{{paramName}}} = match param_{{{paramName}}} {
                                    Some(param_{{{paramName}}}) => param_{{{paramName}}},
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Full::new(Bytes::from("Missing required body parameter {{{baseName}}}")))
                                                        .expect("Unable to create Bad Request response for missing body parameter {{{baseName}}}")),
                                };
        {{/required}}
server-request-body-form.mustache:
{{#vendorExtensions}}
  {{#formParams}}
    {{#-first}}
                                // Form parameters
    {{/-first}}
                                let param_{{{paramName}}} =
      {{^isContainer}}
        {{#vendorExtensions}}
                                    {{{x-example}}};
        {{/vendorExtensions}}
      {{/isContainer}}
      {{#isArray}}
        {{#required}}
                                    Vec::new();
        {{/required}}
        {{^required}}
                                    None;
        {{/required}}
      {{/isArray}}
      {{#isMap}}
                                    None;
      {{/isMap}}
  {{/formParams}}
{{/vendorExtensions}}
server-request-body-instance.mustache:
{{#vendorExtensions}}
  {{#x-consumes-multipart}}
    {{#x-consumes-multipart-related}}
{{>server-request-body-multipart-related}}
    {{/x-consumes-multipart-related}}
    {{^x-consumes-multipart-related}}
      {{^bodyParams}}
{{>server-request-body-multipart-form}}
      {{/bodyParams}}
    {{/x-consumes-multipart-related}}
  {{/x-consumes-multipart}}
  {{^x-consumes-multipart}}
    {{#bodyParams}}
{{>server-request-body-basic}}
    {{/bodyParams}}
    {{^bodyParams}}
{{>server-request-body-form}}
    {{/bodyParams}}
  {{/x-consumes-multipart}}
{{/vendorExtensions}}
server-request-body-multipart-form.mustache:
                                /*
                                let boundary = match swagger::multipart::form::boundary(&headers) {
                                    Some(boundary) => boundary.to_string(),
                                    None => return Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Full::new(Bytes::from("Couldn't find valid multipart body".to_string())))
                                                .expect("Unable to create Bad Request response for incorrect boundary")),
                                }; 
                                */

                                use std::io::Read;

                                // Read Form Parameters from body
                                let mut entries = match Multipart::with_body(&body.to_vec()[..], boundary)
                                    .save()
                                    .size_limit(multipart_form_size_limit)
                                    .temp()
                                {
                                    SaveResult::Full(entries) => {
                                        entries
                                    },
                                    SaveResult::Partial(_, PartialReason::CountLimit) => {
                                        return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Full::new(Bytes::from("Unable to process message part due to excessive parts".to_string())))
                                                        .expect("Unable to create Bad Request response due to excessive parts"))
                                    },
                                    SaveResult::Partial(_, PartialReason::SizeLimit) => {
                                        return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Full::new(Bytes::from("Unable to process message part due to excessive data".to_string())))
                                                        .expect("Unable to create Bad Request response due to excessive data"))
                                    },
                                    SaveResult::Partial(_, PartialReason::Utf8Error(_)) => {
                                        return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Full::new(Bytes::from("Unable to process message part due to invalid data".to_string())))
                                                        .expect("Unable to create Bad Request response due to invalid data"))
                                    },
                                    SaveResult::Partial(_, PartialReason::IoError(_)) => {
                                        return Ok(Response::builder()
                                                        .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                        .body(Full::new(Bytes::from("Failed to process message part due an internal error".to_string())))
                                                        .expect("Unable to create Internal Server Error response due to an internal errror"))
                                    },
                                    SaveResult::Error(e) => {
                                        return Ok(Response::builder()
                                                        .status(StatusCode::INTERNAL_SERVER_ERROR)
                                                        .body(Full::new(Bytes::from("Failed to process all message parts due to an internal error".to_string())))
                                                        .expect("Unable to create Internal Server Error response due to an internal error"))
                                    },
                                };
                {{#formParams}}
                                let field_{{{paramName}}} = entries.fields.remove("{{{paramName}}}");
                                let param_{{{paramName}}} = match field_{{{paramName}}} {
                                    Some(field) => {
                                        let mut reader = field[0].data.readable().expect("Unable to read field for {{{paramName}}}");
                {{^required}}
                                    Some({
                {{/required}}
                                {{#isByteArray}}
                                        let mut data = vec![];
                                        reader.read_to_end(&mut data).expect("Reading saved binary data should never fail");
                                        // swagger::ByteArray(data)
                                {{/isByteArray}}
                                {{^isByteArray}}
                                  {{#jsonSchema}}
                                        let mut data = String::new();
                                        reader.read_to_string(&mut data).expect("Reading saved String should never fail");
                                        let {{{paramName}}}_model: {{{dataType}}} = match serde_json::from_str(&data) {
                                            Ok(model) => model,
                                            Err(e) => {
                                                return Ok(
                                                    Response::builder()
                                                    .status(StatusCode::BAD_REQUEST)
                                                    .body(Full::new(Bytes::from(format!("{{{paramName}}} data does not match API definition : {}", e))))
                                                    .expect("Unable to create Bad Request due to missing required form parameter {{{paramName}}}"))
                                            }
                                        };
                                        {{{paramName}}}_model
                                  {{/jsonSchema}}
                                {{/isByteArray}}
                {{^required}}
                                    })
                {{/required}}
                                    },
                                    None => {
                {{#required}}
                                        return Ok(
                                            Response::builder()
                                            .status(StatusCode::BAD_REQUEST)
                                            .body(Full::new(Bytes::from("Missing required form parameter {{{paramName}}}".to_string())))
                                            .expect("Unable to create Bad Request due to missing required form parameter {{{paramName}}}"))
                {{/required}}
                {{^required}}
                                            None
                {{/required}}
                                    }
                                };
        {{/formParams}}
server-request-body-multipart-related.mustache:
                                // Get multipart chunks.

                                // Create headers from top-level content type header.
                                /*
                                let multipart_headers = match swagger::multipart::related::create_multipart_headers(headers.get(CONTENT_TYPE)) {
                                    Ok(headers) => headers,
                                    Err(e) => {
                                        return Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Full::new(Bytes::from(e)))
                                                .expect("Unable to create Bad Request response due to unable to read content-type header for {{operationId}}"));
                                    }
                                };
                                */

                                // &*body expresses the body as a byteslice, &mut provides a
                                // mutable reference to that byteslice.
                                let nodes = match read_multipart_body(&mut&*body, &multipart_headers, false) {
                                    Ok(nodes) => nodes,
                                    Err(e) => {
                                        return Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Full::new(Bytes::from(format!("Could not read multipart body for {{operationId}}: {}", e))))
                                                .expect("Unable to create Bad Request response due to unable to read multipart body for {{operationId}}"));
                                    }
                                };

{{#formParams}}
let mut param_{{{paramName}}} = None;
{{/formParams}}

                                for node in nodes {
                                    if let Node::Part(part) = node {
                                        let content_type = part.content_type().map(|x| format!("{}",x));
                                        match content_type.as_deref() {
{{#formParams}}
  {{^isBinary}}
                                            Some("{{{contentType}}}") if param_{{{paramName}}}.is_none() => {
                                                // Extract JSON part.
                                                let deserializer = &mut serde_json::Deserializer::from_slice(part.body.as_slice());
                                                let json_data: {{dataType}} = match serde_ignored::deserialize(deserializer, |path| {
                                                    warn!("Ignoring unknown field in JSON part: {}", path);
                                                    unused_elements.push(path.to_string());
                                                }) {
                                                    Ok(json_data) => json_data,
                                                    Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Full::new(Bytes::from(format!("Couldn't parse body parameter {{dataType}} - doesn't match schema: {}", e))))
                                                        .expect("Unable to create Bad Request response for invalid body parameter {{dataType}} due to schema"))
                                                };
                                                // Push JSON part to return object.
                                                param_{{{paramName}}}.get_or_insert(json_data);
                                            },
  {{/isBinary}}
  {{#isBinary}}
                                            Some("{{{contentType}}}") if param_{{{paramName}}}.is_none() => {
                                                param_{{{paramName}}}.get_or_insert(swagger::ByteArray(part.body));
                                            },
  {{/isBinary}}
{{/formParams}}
                                            Some(content_type) => {
                                                warn!("Ignoring unexpected content type: {}", content_type);
                                                unused_elements.push(content_type.to_string());
                                            },
                                            None => {
                                                warn!("Missing content type");
                                            },
                                        }
                                    } else {
                                        unimplemented!("No support for handling unexpected parts");
                                        // unused_elements.push();
                                    }
                                }
{{#formParams}}
  {{#-first}}

                                // Check that the required multipart chunks are present.
  {{/-first}}
  {{#required}}
                                let param_{{{paramName}}} = match param_{{{paramName}}} {
                                    Some(x) => x,
                                    None =>  return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Full::new(Bytes::from("Missing required multipart/related parameter {{{paramName}}}".to_string())))
                                        .expect("Unable to create Bad Request response for missing multipart/related parameter {{{paramName}}} due to schema"))
                                };
  {{/required}}
{{/formParams}}
server-response-body-instance.mustache:
{{#dataType}}
  {{#vendorExtensions}}
    {{^x-produces-multipart-related}}
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("{{{x-mime-type}}}")
                                                            .expect("Unable to create Content-Type header for {{{x-mime-type}}}"));
    {{/x-produces-multipart-related}}
    {{#x-produces-xml}}
                                                    // XML Body
      {{^x-has-namespace}}
                                                    let body = serde_xml_rs::to_string(&body).expect("impossible to fail to serialize");
      {{/x-has-namespace}}
      {{#x-has-namespace}}
                                                    let mut namespaces = std::collections::BTreeMap::new();

                                                    // An empty string is used to indicate a global namespace in xmltree.
                                                    namespaces.insert("".to_string(), {{{dataType}}}::NAMESPACE.to_string());
                                                    let body = serde_xml_rs::to_string_with_namespaces(&body, namespaces).expect("impossible to fail to serialize");
      {{/x-has-namespace}}
    {{/x-produces-xml}}
    {{#x-produces-json}}
                                                    // JSON Body
                                                    let body = serde_json::to_string(&body).expect("impossible to fail to serialize");
    {{/x-produces-json}}
    {{#x-produces-bytes}}
                                                    // Binary Body
                                                    let body = body.0;
    {{/x-produces-bytes}}
    {{#x-produces-plain-text}}
                                                    // Plain text Body
                                                    let body = body;
    {{/x-produces-plain-text}}
    {{#x-produces-multipart-related}}
                                                    // multipart/related Body
      {{#formParams}}
                                                    let param_{{{paramName}}} = body.{{{paramName}}};
      {{/formParams}}
      {{#formParams}}
{{>generate-multipart-related}}
                                                    let header = "multipart/related";
                                                    response.headers_mut().insert(CONTENT_TYPE,
                                                        HeaderValue::from_bytes(
                                                            &["multipart/related; boundary=".as_bytes(), &boundary].concat())
                                                        .expect("Unable to create Content-Type header for multipart/related"));
      {{/formParams}}
    {{/x-produces-multipart-related}}
  {{/vendorExtensions}}
                                                    *response.body_mut() = Full::new(Bytes::from(body));
{{/dataType}}
server-server_auth_.mustache_:
use super::Service;
use crate::{Api, AuthenticationApi};
use swagger::{
    ApiError,
    Authorization, 
    auth::{Basic, Bearer}, 
    Has, 
    XSpanIdString};

impl<T,C> AuthenticationApi for Service<T, C> where
T: Api<C> + Clone + Send + 'static + AuthenticationApi,
C: Has<XSpanIdString> + Has<Option<Authorization>> + Send + Sync + 'static {

    /// Passthrough of the task to the api-implementation
    fn bearer_authorization(&self, token: &Bearer) -> Result<Authorization, ApiError> {
        self.api_impl.bearer_authorization(token)
    }

    /// Passthrough of the task to the api-implementation
    fn apikey_authorization(&self, token: &str) -> Result<Authorization, ApiError> {
        self.api_impl.apikey_authorization(token)
    }

    /// Passthrough of the task to the api-implementation
    fn basic_authorization(&self, basic: &Basic) -> Result<Authorization, ApiError> {
        self.api_impl.basic_authorization(basic)
    }
}
server-service-footer.mustache:
                _ => Ok(Response::builder().status(StatusCode::NOT_FOUND)
                        .body(Full::new(Bytes::new()))
                        .expect("Unable to create Not Found response"))
            }
        }
        Box::pin(run(
            self.api_impl.clone(),
            req,
{{#apiUsesMultipartFormData}}
            self.multipart_form_size_limit,
{{/apiUsesMultipartFormData}}
        ))
    }
}
server-service-header.mustache:
fn method_not_allowed() -> Result<Response<Full<Bytes>>, crate::ServiceError> {
    Ok(
        Response::builder().status(StatusCode::METHOD_NOT_ALLOWED)
            .body(Full::new(Bytes::new()))
            .expect("Unable to create Method Not Allowed response")
    )
}

pub struct Service<T, C> where
    T: Api<C> + Clone + Send + 'static,
    C: Has<XSpanIdString> {{#hasAuthMethods}}+ Has<Option<Authorization>>{{/hasAuthMethods}} + Send + Sync + 'static
{
    api_impl: T,
{{#apiUsesMultipart}}
    multipart_form_size_limit: Option<u64>,
{{/apiUsesMultipart}}
    marker: PhantomData<C>,
}

impl<T, C> Service<T, C> where
    T: Api<C> + Clone + Send + 'static,
    C: Has<XSpanIdString> {{#hasAuthMethods}}+ Has<Option<Authorization>>{{/hasAuthMethods}} + Send + Sync + 'static
{
    pub fn new(api_impl: T) -> Self {
        Service {
            api_impl,
{{#apiUsesMultipart}}
            multipart_form_size_limit: Some(8 * 1024 * 1024),
{{/apiUsesMultipart}}
            marker: PhantomData
        }
    }
{{#apiUsesMultipart}}

    /// Configure size limit when extracting a multipart/form body.
    ///
    /// Default is 8 MiB.
    ///
    /// Set to None for no size limit, which presents a Denial of Service attack risk.
    pub fn multipart_form_size_limit(mut self, multipart_form_size_limit: Option<u64>) -> Self {
        self.multipart_form_size_limit = multipart_form_size_limit;
        self
    }
{{/apiUsesMultipart}}
}

impl<T, C> Clone for Service<T, C> where
    T: Api<C> + Clone + Send + 'static,
    C: Has<XSpanIdString> {{#hasAuthMethods}}+ Has<Option<Authorization>>{{/hasAuthMethods}} + Send + Sync + 'static
{
    fn clone(&self) -> Self {
        Service {
            api_impl: self.api_impl.clone(),
{{#apiUsesMultipart}}
            multipart_form_size_limit: Some(8 * 1024 * 1024),
{{/apiUsesMultipart}}
            marker: self.marker,
        }
    }
}

impl<T, C> hyper::service::Service<(Request<Incoming>, C)> for Service<T, C> where
    T: Api<C> + Clone + Send + Sync + 'static,
    C: Has<XSpanIdString> {{#hasAuthMethods}}+ Has<Option<Authorization>>{{/hasAuthMethods}} + Send + Sync + 'static
{
    type Response = Response<Full<Bytes>>;
    type Error = crate::ServiceError;
    type Future = ServiceFuture;

    fn call(&self, req: (Request<Incoming>, C)) -> Self::Future {
        async fn run<T, C>(
            mut api_impl: T,
            req: (Request<Incoming>, C),
{{#apiUsesMultipartFormData}}
            multipart_form_size_limit: Option<u64>,
{{/apiUsesMultipartFormData}}
        ) -> Result<Response<Full<Bytes>>, crate::ServiceError> where
            T: Api<C> + Clone + Send + 'static,
            C: Has<XSpanIdString> {{#hasAuthMethods}}+ Has<Option<Authorization>>{{/hasAuthMethods}} + Send + Sync + 'static
        {
            let (request, context) = req;
            let (parts, body) = request.into_parts();
            let (method, uri, headers) = (parts.method, parts.uri, parts.headers);
            let path = paths::GLOBAL_REGEX_SET.matches(uri.path());

            {{!
            This match statement is duplicated below in `parse_operation_id()`.
            Please update both places if changing how this code is autogenerated.
            }}
            match method {
